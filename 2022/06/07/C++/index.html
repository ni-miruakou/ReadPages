<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>标题</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="C++函数内联函数1inline [function declear also definition struct] 引用变量修改调用对象 加快运行速度 别名（左值引用）1[type]  &amp;[variable name]&#x3D;[variable]; 按引用传递1[type]  &amp;[parameter] 声明引用变量为const，从而允许不可修改的值的按引用传递 右值引用1[type]">
<meta property="og:type" content="article">
<meta property="og:title" content="标题">
<meta property="og:url" content="https://ni-miruakou.github.io/2022/06/07/C++/index.html">
<meta property="og:site_name" content="标题">
<meta property="og:description" content="C++函数内联函数1inline [function declear also definition struct] 引用变量修改调用对象 加快运行速度 别名（左值引用）1[type]  &amp;[variable name]&#x3D;[variable]; 按引用传递1[type]  &amp;[parameter] 声明引用变量为const，从而允许不可修改的值的按引用传递 右值引用1[type]">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-06T17:44:37.842Z">
<meta property="article:modified_time" content="2022-03-28T12:35:20.659Z">
<meta property="article:author" content="Rongbing">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="标题" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">标题</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">副标题</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ni-miruakou.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-C++" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/C++/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.842Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> [function declear also definition <span class="keyword">struct</span>]</span><br></pre></td></tr></table></figure>
<h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>修改调用对象</p>
<p>加快运行速度</p>
<h4 id="别名（左值引用）"><a href="#别名（左值引用）" class="headerlink" title="别名（左值引用）"></a>别名（左值引用）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[type]  &amp;[variable name]=[variable];</span><br></pre></td></tr></table></figure>
<h4 id="按引用传递"><a href="#按引用传递" class="headerlink" title="按引用传递"></a>按引用传递</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[type]  &amp;[parameter]</span><br></pre></td></tr></table></figure>
<p>声明引用变量为<code>const</code>，从而允许不可修改的值的按引用传递</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[type]  &amp;&amp;[variable name]=[value];</span><br></pre></td></tr></table></figure>
<h4 id="函数返回引用"><a href="#函数返回引用" class="headerlink" title="函数返回引用"></a>函数返回引用</h4><p>要求返回的变量超越函数生命周期存在</p>
<h4 id="基类引用"><a href="#基类引用" class="headerlink" title="基类引用"></a>基类引用</h4><p>可以指向派生类对象，因为派生类继承了基类的特性</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*parameter:*/</span> [type] [parameter]=[<span class="keyword">default</span> value]</span><br></pre></td></tr></table></figure>
<p>默认参数集中在参数列表末尾</p>
<p>不允许跳过参数赋值，即使被跳过的参数有默认值</p>
<h3 id="函数重载-多态-overload"><a href="#函数重载-多态-overload" class="headerlink" title="函数重载|多态  overload"></a>函数重载|多态  overload</h3><p>函数特征标function signature：参数列表的1、数目2、类型3、排列顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[same type]  [same function name]\([different parameter list...])</span><br></pre></td></tr></table></figure>
<p>没有匹配类型时尝试强制转换参数类型，但是若有多种类型能够通过强制转换符合则失败</p>
<p>无法区分参数引用和参数调用，无法区分<code>const</code></p>
<p>不允许仅区分返回值类型，但可以返回值类型不同</p>
<p>若有参数引用类型不同的多态调用时时可以匹配最优态，如type&amp;对应type、const type&amp;对应const type、type&amp;&amp;对应value，但是如果最优态不存在则匹配到可用的const type&amp;</p>
<p>编译器内部进行名称修饰name decoration|名称矫正name mangling来实现函数重载过程</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>使用泛型定义函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>||<span class="keyword">class</span> [parameterized type name,usually <span class="string">&#x27;T&#x27;</span>]&gt;</span><br><span class="line"></span><br><span class="line">[parameterized type name] [parameter]</span><br></pre></td></tr></table></figure>
<p>下述模板各类<strong>具体化specialization</strong></p>
<h4 id="隐式实例化implicit-instantiation"><a href="#隐式实例化implicit-instantiation" class="headerlink" title="隐式实例化implicit instantiation"></a>隐式实例化implicit instantiation</h4><p>调用函数时，编译器会参考参数类型，根据模板生成应用于特定类型的代码实例instantiation</p>
<h4 id="显式具体化Explicit-Specialization"><a href="#显式具体化Explicit-Specialization" class="headerlink" title="显式具体化Explicit Specialization"></a>显式具体化Explicit Specialization</h4><p>适用于模板不完全适用于所有类型，需要重新定义函数</p>
<p>优先级高于模板函数，低于非模板函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; [type]  \[function]\&lt;[boolean-optional specific type]&gt;([parameter list with in specific type...])</span><br></pre></td></tr></table></figure>
<h4 id="显式实例化Explicit-Instantiation"><a href="#显式实例化Explicit-Instantiation" class="headerlink" title="显式实例化Explicit Instantiation"></a>显式实例化Explicit Instantiation</h4><p>函数声明，要求编译器根据模板生成指定类型的代码实例，与具体化不同的是它不允许函数定义，且它的优先级低</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">templete  [type]  [function]&lt;[specific type]&gt;([parameter list with in specific type...])</span><br></pre></td></tr></table></figure>
<p>函数调用，要求按照指定类型使用该函数，按照该类型的实例函数要求接受参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[function]&lt;[specific type]&gt;(arguments...)</span><br></pre></td></tr></table></figure>
<h3 id="重载解析overloading-resolution"><a href="#重载解析overloading-resolution" class="headerlink" title="重载解析overloading resolution"></a>重载解析overloading resolution</h3><ol>
<li>创建候选函数列表（同名函数）</li>
<li>匹配参数列表（模板具体化，强制转换）</li>
<li>确定最优函数<ol>
<li>完全匹配（容许引用与值，数组与指针，变量到<code>const</code>或<code>volatile</code>等的类型转换）<ol>
<li>常规函数</li>
<li>模板</li>
</ol>
</li>
<li>提升转换（整型向更大范围，浮点型向精确）</li>
<li>标准转换（强制转换）</li>
<li>用户定义</li>
</ol>
</li>
</ol>
<h4 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h4><p>在模板函数内可能用到类型提升后的变量</p>
<p>将变量声明为与表达式相同的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delctype</span>([expression])  [variable];</span><br></pre></td></tr></table></figure>
<p>模板函数无法确定它具体返回值的类型</p>
<p>后置返回类型trailing return type</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>  [function]([parameter list...])-&gt;<span class="built_in">delctype</span>([expression])</span><br></pre></td></tr></table></figure>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>翻译单元translation unit，C++中进行编译的单元，一般理解为文件</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>存储</th>
<th>持续</th>
<th>作用域</th>
<th>链接</th>
<th>声明域</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动/寄存器</td>
<td>自动</td>
<td>代码块</td>
<td>无</td>
<td>代码块，或并且使用register</td>
</tr>
<tr>
<td>静态无链接</td>
<td></td>
<td>代码块</td>
<td>无</td>
<td>代码块，并且使用static</td>
</tr>
<tr>
<td>静态，外部链接</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>不在任何函数内</td>
</tr>
<tr>
<td>静态，内部链接</td>
<td></td>
<td>文件</td>
<td>内部</td>
<td>不在任何函数内，并且使用static</td>
</tr>
</tbody>
</table>
</div>
<h3 id="存储持续性"><a href="#存储持续性" class="headerlink" title="存储持续性"></a>存储持续性</h3><ul>
<li>自动：在结构中</li>
<li>静态：<code>static</code>  在程序中</li>
<li>线程：<code>thread_local</code>  在线程中</li>
<li>动态：<code>new</code> <code>delete</code>  动态持续，free store/heap</li>
</ul>
<h3 id="作用域scope"><a href="#作用域scope" class="headerlink" title="作用域scope"></a>作用域scope</h3><p>变量名称可见范围</p>
<ul>
<li>局部，代码块（花括号内）</li>
<li>全局（文件），函数</li>
<li>类</li>
<li>名称空间<code>namespace</code></li>
</ul>
<h3 id="链接性linkage"><a href="#链接性linkage" class="headerlink" title="链接性linkage"></a>链接性linkage</h3><p>变量在文件间共享否，在程序内存在，缺省初始化为0 zero-initialized</p>
<ul>
<li>内部</li>
<li>外部</li>
<li>无</li>
</ul>
<h4 id="单定义规则ODR-one-definition-rule"><a href="#单定义规则ODR-one-definition-rule" class="headerlink" title="单定义规则ODR  one definition rule"></a>单定义规则ODR  one definition rule</h4><p>只允许定义一次变量</p>
<p>首次：定义声明defining declaration/definition</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[type] [variable name];</span><br></pre></td></tr></table></figure>
<p>其他文件：引用声明referencing declaration/declaration</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> [type] [variable];</span><br></pre></td></tr></table></figure>
<h4 id="函数链接性"><a href="#函数链接性" class="headerlink" title="函数链接性"></a>函数链接性</h4><p>默认函数原型带有<code>extern</code>，即在所有属于程序的文件和库中查找和使用该函数</p>
<p>原型和定义为<code>static</code>，只在文件内查找和使用该函数，不允许被其他文件查找和使用</p>
<p>单定义规则，不允许函数多重定义</p>
<p>允许内联函数多重定义，但定义体必须一致，以保证可将内联函数直接放在头文件</p>
<h4 id="语言链接性language-linking"><a href="#语言链接性language-linking" class="headerlink" title="语言链接性language linking"></a>语言链接性language linking</h4><p>要求名称修饰采用C语言标准</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> [function prototype];</span><br></pre></td></tr></table></figure>
<h3 id="存储说明符和cv-限定符storage-class-specifier-cv-qualifier"><a href="#存储说明符和cv-限定符storage-class-specifier-cv-qualifier" class="headerlink" title="存储说明符和cv-限定符storage class specifier cv-qualifier"></a>存储说明符和cv-限定符storage class specifier cv-qualifier</h3><p><code>auto</code>，自动变量/自动类型推断</p>
<p><code>register</code> 寄存器存储/自动变量</p>
<p><code>static</code> 静态+内部</p>
<p><code>extern</code> 引用</p>
<p><code>thread_local</code>，附加说明符，线程持续性</p>
<p><code>mutable</code>，作为成员可变，不论从属的结构体或类是否为const</p>
<p><code>const</code>，常量，默认全局常量的链接性为内部</p>
<p><code>volatile</code>，不稳定</p>
<h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p>new-delete</p>
<p>分配变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[variable] = <span class="keyword">new</span>  [type]</span><br><span class="line"><span class="keyword">delete</span> [variable]</span><br></pre></td></tr></table></figure>
<p>分配数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[type*][variable] = <span class="keyword">new</span>  [type][[count of unit]]</span><br><span class="line"><span class="keyword">delete</span> [] [variable];</span><br></pre></td></tr></table></figure>
<p>分配值且初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>  [type]([value])</span><br></pre></td></tr></table></figure>
<p>分配结构体且初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>  [<span class="keyword">struct</span>]&#123;[<span class="keyword">struct</span> member value list,...]&#125;</span><br></pre></td></tr></table></figure>
<p>原理：基于运算符重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="comment">//-&gt;  new(sizeof([type]))</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[]<span class="params">(std::<span class="type">size_t</span>)</span> <span class="comment">//-&gt;  new(sizeof([count of unit]*[type]))</span></span></span><br></pre></td></tr></table></figure>
<p>可替换，可重载，以便定制化</p>
<p>定位new  placement，在指定位置分配内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ([pointer of decleared buffer])  ([statement of the <span class="keyword">new</span> function])</span><br></pre></td></tr></table></figure>
<p>不可替换定位new，可以重载，第一个参数是std::size_t，第二个自主决定，其他可有可无</p>
<p>不允许对已分配的空间使用delete</p>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><p>位于全局，可嵌套，不可位于代码块，开放的可附加</p>
<p>声明区域declaration region，声明所在的生命周期</p>
<p>潜在作用域potential scope，变量声明至生命周期结束</p>
<p>定义名称空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>  [<span class="keyword">namespace</span> name]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局名称空间global namespace 对应于文件声明区域，自然存在</p>
<p>限定名称空间 qualified</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">namespace</span>]::[name]</span><br></pre></td></tr></table></figure>
<p>使用名称空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> [<span class="keyword">namespace</span>];</span><br></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>面向对象编程OOP：抽象，封装和数据隐藏，多态，继承，可重用性</p>
<p>基本类型：占用空间，解释空间，空间操作</p>
<p>类：类声明（数据成员，成员函数）；类方法定义</p>
<p>不允许非成员函数访问类中的<code>private</code></p>
<p>在类中定义的函数是内联函数</p>
<p>定义类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [Class name]&#123;</span><br><span class="line">    <span class="comment">//default private:</span></span><br><span class="line">    [私有成员函数...]</span><br><span class="line">    [私有数据成员...]</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    [私有成员函数...]</span><br><span class="line">    [私有数据成员...]</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    [公有成员函数...]</span><br><span class="line">    [公有数据成员...]</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    [受保护成员函数...]</span><br><span class="line">    [受保护数据成员...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明和定义类成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">return</span> type] [Class]::[function head]</span><br></pre></td></tr></table></figure>
<h3 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h3><p>声明对象时自动调用，不允许手动调用</p>
<p>没有返回值和类型</p>
<p>存在一个缺省的构造函数，定义为空，但是如果有已定义构造函数缺省构造函数将失效，可以重载一个无参数构造函数态来允许使用缺省构造函数</p>
<p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Class]::[<span class="built_in">Class</span> (,same as <span class="keyword">class</span> name)](parameter <span class="built_in">list</span>(usually m_parameterName),...)</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式</span></span><br><span class="line">[Class] [object name]=[Class](arguments,...);</span><br><span class="line"><span class="comment">//隐式</span></span><br><span class="line">[Class] [object name](arguments,...);</span><br><span class="line"><span class="comment">//指针</span></span><br><span class="line">[Class] [*pointer name of object]=<span class="keyword">new</span> [Class](arguments,...);</span><br></pre></td></tr></table></figure>
<p>可以采用列表初始化，列表为构造函数的参数列表</p>
<p>如果构造函数接受仅一个参数，可以通过赋值的方式初始化对象，但是为了避免出现问题，可以关闭这项特性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Class] [object]=value;</span><br></pre></td></tr></table></figure>
<h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><p>构造函数只接受一个必要参数的态可以用于类型转换，将类型转换为类</p>
<p>重载操作符重载符为类型时可以用于类型转换，将类转换为类型</p>
<p>如果有多个态接受类型或转换类型而来的类型，意味着存在二义性，编译失败</p>
<p><code>explcit</code>将禁止自动类型转换，只允许强制类型转换，在一定程度上避免二义性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐私或显式，向类转换，基于构造函数</span></span><br><span class="line">[<span class="built_in">Class</span> (,same as <span class="keyword">class</span> name)]([type] [parameter],[other parameter with <span class="keyword">default</span> value,...])</span><br><span class="line"><span class="comment">//显式，向类转换，基于构造函数</span></span><br><span class="line"><span class="keyword">explicit</span> [<span class="built_in">Class</span> (,same as <span class="keyword">class</span> name)]([type] [parameter],[other parameter with <span class="keyword">default</span> value,...])</span><br><span class="line"><span class="comment">//向类型转换，基于运算符重载</span></span><br><span class="line"><span class="keyword">operator</span> [<span class="keyword">typename</span>]()</span><br></pre></td></tr></table></figure>
<h3 id="类析构函数"><a href="#类析构函数" class="headerlink" title="类析构函数"></a>类析构函数</h3><p>对象过期时调用（何时过期参考存储持续性），一般不要显式调用</p>
<p>没有参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Class]::[~Class]()</span><br></pre></td></tr></table></figure>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>如果类中包含指向new分配内存的指针，应该复制</p>
<p>对象复制，初始化对象为现有对象时调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Class]::[Class](<span class="type">const</span> [<span class="keyword">class</span>] &amp;)</span><br></pre></td></tr></table></figure>
<p>默认复制为浅复制，成员复制，逐个复制非静态成员，意味着成员指向的内存不会被复制</p>
<p>深复制包括复制指向性内存</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><h3 id="地址运算符"><a href="#地址运算符" class="headerlink" title="地址运算符"></a>地址运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">class</span>]::<span class="keyword">operator</span>[](<span class="type">int</span> [variable]);</span><br></pre></td></tr></table></figure>
<h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a><code>const</code>成员函数</h3><p>允许有无声明const的同名函数同时存在，对于非const类优先调用非const的重载函数</p>
<p>对于声明为常量对象，需要成员函数保证不修改类。否则不允许调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[function head] <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>重载已有的运算符op，包括数组索引符[]，new，new[]，delete，delete[]，x++，++x</p>
<p>不可以重载所有参数都为固有数据类型的情况，以免非预期情况</p>
<p>运算符接受参数数目不会改变，优先级不会改变，嵌套性不会改变</p>
<p>有些不许重载，有些可以重载，有些只能作为成员函数时重载</p>
<p>作为成员函数重载，左侧为类，右侧为参数列表；作为非成员函数重载，操作符的操作数依次出现在参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载运算符函数头</span></span><br><span class="line">[<span class="keyword">return</span> type] <span class="keyword">operator</span> [op]([parament list])</span><br></pre></td></tr></table></figure>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>具有与类相同的访问权限，需要与成员函数一道声明，不可作为成员函数</p>
<p>解决运算符重载时非成员函数希望访问对象的情况</p>
<p>友元函数声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> [function declaration]<span class="comment">//在类内</span></span><br></pre></td></tr></table></figure>
<p>定义不需要<code>friend</code></p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><code>this</code>指针</h3><p>指向本身的指针</p>
<p><code>*this</code>对象本身</p>
<h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>与普通数组差不多</p>
<h3 id="公有常量"><a href="#公有常量" class="headerlink" title="公有常量"></a>公有常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">enum</span>&#123;[<span class="type">const</span> variable name]=[value],...&#125;;	</span><br><span class="line"><span class="comment">//避免名称冲突而定义的类内作用枚举</span></span><br><span class="line"><span class="keyword">enum</span> [<span class="keyword">class</span>|<span class="keyword">struct</span>] [<span class="keyword">enum</span> <span class="title class_">name</span>]&#123;[<span class="type">const</span> variable name]=[value],...&#125;<span class="comment">//定义</span></span><br><span class="line">[<span class="keyword">enum</span>]::[<span class="type">const</span> variable]<span class="comment">//使用</span></span><br><span class="line"><span class="comment">//静态常量</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> [type] [variable]=[value];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>静态成员仅在类声明外才能初始化，但静态常量和静态枚举不受此限制。</p>
<h3 id="动态类"><a href="#动态类" class="headerlink" title="动态类"></a>动态类</h3><p>避免指针对应内存已经释放，导致{使用空内存，释放空内存}</p>
<p>赋值和传参操作会引起类的增加，需要对指针提供额外内存；</p>
<p>函数结束会调用类的析构函数，需要保证析构的内存有效；</p>
<p>负责动态的：</p>
<p>静态成员：记录类的个数，以便对应内存，静态成员仅在类声明外才能初始化，但静态常量和静态枚举不受此限制。</p>
<p>构造函数：多个构造函数时，即使传入单个值也使用<code>new []</code>，即时传入常量值也使用<code>new</code>和<code>strcpy</code>来配合析构函数<code>delete []</code>，对<code>new</code>使用<code>delete[]</code>可能出错 <a href="#构造函数">关于构造函数</a> <a href="#动态分配">关于new</a></p>
<p>折构函数：对应指针使用<code>delete []</code>释放内存 <a href="#折构函数">关于</a></p>
<p>复制构造函数：需要重载并复制内存 <a href="#复制构造函数">关于</a></p>
<p>赋值运算符：重载，考虑赋值给自身的情况，同时复制内存 <a href="#赋值运算符">关于</a></p>
<p>地址运算符：重载，以实现动态内存的索引 <a href="#地址运算符">关于</a></p>
<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><h3 id="派生"><a href="#派生" class="headerlink" title="派生"></a>派生</h3><p>继承基类的实现和接口，需要自己的构造函数和额外成员和成员函数。</p>
<p>公有派生</p>
<p>不能访问基类的私有成员，意味需要调用基类的构造函数</p>
<p>公有派生</p>
<p>公有派生</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [sub_class] : [access-specifier] [parent_class]&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>智能指针模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line">auto_ptr	<span class="comment">//自动指针，带有释放所指向内存的析构函数，但是没有考虑指针共享</span></span><br><span class="line">shared_ptr	<span class="comment">//共享指针，能够让指向同一块内存的多个指针正常访问和删除</span></span><br><span class="line">unique_ptr	<span class="comment">//独特指针，只允许一个指针指向某一块内存，违反则在编译阶段报错，但是编译器应当接受也确实接受指向同一块内存的指针的传递</span></span><br><span class="line">    ptr1=<span class="built_in">fun</span>()&#123;<span class="keyword">return</span> ptr0;&#125;</span><br><span class="line">    ptr1=std::<span class="built_in">move</span>(ptr0)<span class="comment">//指针的传递</span></span><br><span class="line">weak_ptr</span><br><span class="line">scoped_ptr<span class="comment">//boost.lib</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//只允许指向由new分配的内存</span></span><br><span class="line">[[<span class="keyword">auto</span>|shared|unique]_ptr]&lt;[type]&gt; [variable]=<span class="keyword">new</span> [type];</span><br><span class="line"><span class="comment">//只允许指向由new[]分配的内存</span></span><br><span class="line">[unique_ptr]&lt;[type]&gt; [variable]=<span class="keyword">new</span> [type][];</span><br></pre></td></tr></table></figure>
<h2 id="标准模板库STL"><a href="#标准模板库STL" class="headerlink" title="标准模板库STL"></a>标准模板库STL</h2><p>容器、迭代器、函数对象、算法</p>
<p>创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">template</span>]&lt;[type]&gt; [variable name]([count])</span><br></pre></td></tr></table></figure>
<p>迭代器（广义指针）</p>
<p>迭代器使得算法从数据结构中脱离而专注于算法本身的实现，包括了对元素的索引，访问和对超尾的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[stl_class]&lt;[type]&gt;::iterator [iterator name];<span class="comment">//声明</span></span><br><span class="line">[iterator]=[object].<span class="built_in">begin</span>();<span class="comment">//初始化迭代器</span></span><br><span class="line">*[iterator]<span class="comment">//访问对象</span></span><br><span class="line">++[iterator]<span class="comment">//下一个对象迭代</span></span><br><span class="line">[iterator1],[iterator2]<span class="comment">//表示从1到2的之前的区间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ar=iterator1;ar!=iterator2;ar++)</span><br></pre></td></tr></table></figure>
<p>模板类 向量vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;[type]&gt; [variable](count of elements)</span><br><span class="line">    <span class="comment">//一般方法，STL都有</span></span><br><span class="line">    .<span class="built_in">size</span>()</span><br><span class="line">    .<span class="built_in">swap</span>()</span><br><span class="line">    .<span class="built_in">begin</span>()</span><br><span class="line">    .<span class="built_in">end</span>()<span class="comment">//最后一个元素之后的位置</span></span><br><span class="line">    <span class="comment">//特殊方法</span></span><br><span class="line">    .<span class="built_in">push_back</span>(type);<span class="comment">//追加</span></span><br><span class="line">    .<span class="built_in">erase</span>(begin_iterator,end_iterator+<span class="number">1</span>);<span class="comment">//删除</span></span><br><span class="line">    .<span class="built_in">insert</span>(pos_target_iterator,begin_source_iterator,end_source_iterator+<span class="number">1</span>);<span class="comment">//插入</span></span><br><span class="line">    <span class="comment">//非成员方法</span></span><br><span class="line">    .for_each(begin_iterator,end_iterator+<span class="number">1</span>,<span class="type">void</span>*(ReadOnlyFunction)(type));<span class="comment">//逐元素操作</span></span><br><span class="line">	.<span class="keyword">for</span>(type [tmp_variable]:[stl_variable])&#123;</span><br><span class="line">        <span class="comment">//不同于for_each，能够引用x从而修改stl_variable的成员</span></span><br><span class="line">    &#125;<span class="comment">//范围for，针对stl_variable逐元素操作//C++11</span></span><br><span class="line">    .<span class="built_in">Random_shuffle</span>(begin_iterator,end_iterator+<span class="number">1</span>);<span class="comment">//随机重排</span></span><br><span class="line">	.<span class="built_in">sort</span>(begin_iterator,end_iterator+<span class="number">1</span>)<span class="comment">//内排序，采用成员函数operate&lt;()升序</span></span><br><span class="line">    .<span class="built_in">sort</span>(begin_iterator,end_iterator+<span class="number">1</span>,<span class="type">bool</span>*(SortFunction)(type&amp;,type&amp;))<span class="comment">//内排序，采用成员函数operate&lt;()升序</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/C++/" data-id="cl430wi3v0002akfcd7ez8ata" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/06/07/Android/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Es/" rel="tag">Es</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WAP/" rel="tag">WAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/about/" rel="tag">about</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Es/" style="font-size: 10px;">Es</a> <a href="/tags/WAP/" style="font-size: 10px;">WAP</a> <a href="/tags/about/" style="font-size: 10px;">about</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/07/C++/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/07/Android/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/07/UWP/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/07/ProcessService/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/07/OpenGL/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Rongbing<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>