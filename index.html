<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>标题</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="概述">
<meta property="og:type" content="website">
<meta property="og:title" content="标题">
<meta property="og:url" content="https://ni-miruakou.github.io/index.html">
<meta property="og:site_name" content="标题">
<meta property="og:description" content="概述">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Rongbing">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="标题" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">标题</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">副标题</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ni-miruakou.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-C++" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/C++/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.842Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> [function declear also definition <span class="keyword">struct</span>]</span><br></pre></td></tr></table></figure>
<h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>修改调用对象</p>
<p>加快运行速度</p>
<h4 id="别名（左值引用）"><a href="#别名（左值引用）" class="headerlink" title="别名（左值引用）"></a>别名（左值引用）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[type]  &amp;[variable name]=[variable];</span><br></pre></td></tr></table></figure>
<h4 id="按引用传递"><a href="#按引用传递" class="headerlink" title="按引用传递"></a>按引用传递</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[type]  &amp;[parameter]</span><br></pre></td></tr></table></figure>
<p>声明引用变量为<code>const</code>，从而允许不可修改的值的按引用传递</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[type]  &amp;&amp;[variable name]=[value];</span><br></pre></td></tr></table></figure>
<h4 id="函数返回引用"><a href="#函数返回引用" class="headerlink" title="函数返回引用"></a>函数返回引用</h4><p>要求返回的变量超越函数生命周期存在</p>
<h4 id="基类引用"><a href="#基类引用" class="headerlink" title="基类引用"></a>基类引用</h4><p>可以指向派生类对象，因为派生类继承了基类的特性</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*parameter:*/</span> [type] [parameter]=[<span class="keyword">default</span> value]</span><br></pre></td></tr></table></figure>
<p>默认参数集中在参数列表末尾</p>
<p>不允许跳过参数赋值，即使被跳过的参数有默认值</p>
<h3 id="函数重载-多态-overload"><a href="#函数重载-多态-overload" class="headerlink" title="函数重载|多态  overload"></a>函数重载|多态  overload</h3><p>函数特征标function signature：参数列表的1、数目2、类型3、排列顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[same type]  [same function name]\([different parameter list...])</span><br></pre></td></tr></table></figure>
<p>没有匹配类型时尝试强制转换参数类型，但是若有多种类型能够通过强制转换符合则失败</p>
<p>无法区分参数引用和参数调用，无法区分<code>const</code></p>
<p>不允许仅区分返回值类型，但可以返回值类型不同</p>
<p>若有参数引用类型不同的多态调用时时可以匹配最优态，如type&amp;对应type、const type&amp;对应const type、type&amp;&amp;对应value，但是如果最优态不存在则匹配到可用的const type&amp;</p>
<p>编译器内部进行名称修饰name decoration|名称矫正name mangling来实现函数重载过程</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>使用泛型定义函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>||<span class="keyword">class</span> [parameterized type name,usually <span class="string">&#x27;T&#x27;</span>]&gt;</span><br><span class="line"></span><br><span class="line">[parameterized type name] [parameter]</span><br></pre></td></tr></table></figure>
<p>下述模板各类<strong>具体化specialization</strong></p>
<h4 id="隐式实例化implicit-instantiation"><a href="#隐式实例化implicit-instantiation" class="headerlink" title="隐式实例化implicit instantiation"></a>隐式实例化implicit instantiation</h4><p>调用函数时，编译器会参考参数类型，根据模板生成应用于特定类型的代码实例instantiation</p>
<h4 id="显式具体化Explicit-Specialization"><a href="#显式具体化Explicit-Specialization" class="headerlink" title="显式具体化Explicit Specialization"></a>显式具体化Explicit Specialization</h4><p>适用于模板不完全适用于所有类型，需要重新定义函数</p>
<p>优先级高于模板函数，低于非模板函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; [type]  \[function]\&lt;[boolean-optional specific type]&gt;([parameter list with in specific type...])</span><br></pre></td></tr></table></figure>
<h4 id="显式实例化Explicit-Instantiation"><a href="#显式实例化Explicit-Instantiation" class="headerlink" title="显式实例化Explicit Instantiation"></a>显式实例化Explicit Instantiation</h4><p>函数声明，要求编译器根据模板生成指定类型的代码实例，与具体化不同的是它不允许函数定义，且它的优先级低</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">templete  [type]  [function]&lt;[specific type]&gt;([parameter list with in specific type...])</span><br></pre></td></tr></table></figure>
<p>函数调用，要求按照指定类型使用该函数，按照该类型的实例函数要求接受参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[function]&lt;[specific type]&gt;(arguments...)</span><br></pre></td></tr></table></figure>
<h3 id="重载解析overloading-resolution"><a href="#重载解析overloading-resolution" class="headerlink" title="重载解析overloading resolution"></a>重载解析overloading resolution</h3><ol>
<li>创建候选函数列表（同名函数）</li>
<li>匹配参数列表（模板具体化，强制转换）</li>
<li>确定最优函数<ol>
<li>完全匹配（容许引用与值，数组与指针，变量到<code>const</code>或<code>volatile</code>等的类型转换）<ol>
<li>常规函数</li>
<li>模板</li>
</ol>
</li>
<li>提升转换（整型向更大范围，浮点型向精确）</li>
<li>标准转换（强制转换）</li>
<li>用户定义</li>
</ol>
</li>
</ol>
<h4 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h4><p>在模板函数内可能用到类型提升后的变量</p>
<p>将变量声明为与表达式相同的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delctype</span>([expression])  [variable];</span><br></pre></td></tr></table></figure>
<p>模板函数无法确定它具体返回值的类型</p>
<p>后置返回类型trailing return type</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>  [function]([parameter list...])-&gt;<span class="built_in">delctype</span>([expression])</span><br></pre></td></tr></table></figure>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>翻译单元translation unit，C++中进行编译的单元，一般理解为文件</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>存储</th>
<th>持续</th>
<th>作用域</th>
<th>链接</th>
<th>声明域</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动/寄存器</td>
<td>自动</td>
<td>代码块</td>
<td>无</td>
<td>代码块，或并且使用register</td>
</tr>
<tr>
<td>静态无链接</td>
<td></td>
<td>代码块</td>
<td>无</td>
<td>代码块，并且使用static</td>
</tr>
<tr>
<td>静态，外部链接</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>不在任何函数内</td>
</tr>
<tr>
<td>静态，内部链接</td>
<td></td>
<td>文件</td>
<td>内部</td>
<td>不在任何函数内，并且使用static</td>
</tr>
</tbody>
</table>
</div>
<h3 id="存储持续性"><a href="#存储持续性" class="headerlink" title="存储持续性"></a>存储持续性</h3><ul>
<li>自动：在结构中</li>
<li>静态：<code>static</code>  在程序中</li>
<li>线程：<code>thread_local</code>  在线程中</li>
<li>动态：<code>new</code> <code>delete</code>  动态持续，free store/heap</li>
</ul>
<h3 id="作用域scope"><a href="#作用域scope" class="headerlink" title="作用域scope"></a>作用域scope</h3><p>变量名称可见范围</p>
<ul>
<li>局部，代码块（花括号内）</li>
<li>全局（文件），函数</li>
<li>类</li>
<li>名称空间<code>namespace</code></li>
</ul>
<h3 id="链接性linkage"><a href="#链接性linkage" class="headerlink" title="链接性linkage"></a>链接性linkage</h3><p>变量在文件间共享否，在程序内存在，缺省初始化为0 zero-initialized</p>
<ul>
<li>内部</li>
<li>外部</li>
<li>无</li>
</ul>
<h4 id="单定义规则ODR-one-definition-rule"><a href="#单定义规则ODR-one-definition-rule" class="headerlink" title="单定义规则ODR  one definition rule"></a>单定义规则ODR  one definition rule</h4><p>只允许定义一次变量</p>
<p>首次：定义声明defining declaration/definition</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[type] [variable name];</span><br></pre></td></tr></table></figure>
<p>其他文件：引用声明referencing declaration/declaration</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> [type] [variable];</span><br></pre></td></tr></table></figure>
<h4 id="函数链接性"><a href="#函数链接性" class="headerlink" title="函数链接性"></a>函数链接性</h4><p>默认函数原型带有<code>extern</code>，即在所有属于程序的文件和库中查找和使用该函数</p>
<p>原型和定义为<code>static</code>，只在文件内查找和使用该函数，不允许被其他文件查找和使用</p>
<p>单定义规则，不允许函数多重定义</p>
<p>允许内联函数多重定义，但定义体必须一致，以保证可将内联函数直接放在头文件</p>
<h4 id="语言链接性language-linking"><a href="#语言链接性language-linking" class="headerlink" title="语言链接性language linking"></a>语言链接性language linking</h4><p>要求名称修饰采用C语言标准</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> [function prototype];</span><br></pre></td></tr></table></figure>
<h3 id="存储说明符和cv-限定符storage-class-specifier-cv-qualifier"><a href="#存储说明符和cv-限定符storage-class-specifier-cv-qualifier" class="headerlink" title="存储说明符和cv-限定符storage class specifier cv-qualifier"></a>存储说明符和cv-限定符storage class specifier cv-qualifier</h3><p><code>auto</code>，自动变量/自动类型推断</p>
<p><code>register</code> 寄存器存储/自动变量</p>
<p><code>static</code> 静态+内部</p>
<p><code>extern</code> 引用</p>
<p><code>thread_local</code>，附加说明符，线程持续性</p>
<p><code>mutable</code>，作为成员可变，不论从属的结构体或类是否为const</p>
<p><code>const</code>，常量，默认全局常量的链接性为内部</p>
<p><code>volatile</code>，不稳定</p>
<h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p>new-delete</p>
<p>分配变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[variable] = <span class="keyword">new</span>  [type]</span><br><span class="line"><span class="keyword">delete</span> [variable]</span><br></pre></td></tr></table></figure>
<p>分配数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[type*][variable] = <span class="keyword">new</span>  [type][[count of unit]]</span><br><span class="line"><span class="keyword">delete</span> [] [variable];</span><br></pre></td></tr></table></figure>
<p>分配值且初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>  [type]([value])</span><br></pre></td></tr></table></figure>
<p>分配结构体且初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>  [<span class="keyword">struct</span>]&#123;[<span class="keyword">struct</span> member value list,...]&#125;</span><br></pre></td></tr></table></figure>
<p>原理：基于运算符重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="comment">//-&gt;  new(sizeof([type]))</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[]<span class="params">(std::<span class="type">size_t</span>)</span> <span class="comment">//-&gt;  new(sizeof([count of unit]*[type]))</span></span></span><br></pre></td></tr></table></figure>
<p>可替换，可重载，以便定制化</p>
<p>定位new  placement，在指定位置分配内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ([pointer of decleared buffer])  ([statement of the <span class="keyword">new</span> function])</span><br></pre></td></tr></table></figure>
<p>不可替换定位new，可以重载，第一个参数是std::size_t，第二个自主决定，其他可有可无</p>
<p>不允许对已分配的空间使用delete</p>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><p>位于全局，可嵌套，不可位于代码块，开放的可附加</p>
<p>声明区域declaration region，声明所在的生命周期</p>
<p>潜在作用域potential scope，变量声明至生命周期结束</p>
<p>定义名称空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>  [<span class="keyword">namespace</span> name]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局名称空间global namespace 对应于文件声明区域，自然存在</p>
<p>限定名称空间 qualified</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">namespace</span>]::[name]</span><br></pre></td></tr></table></figure>
<p>使用名称空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> [<span class="keyword">namespace</span>];</span><br></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>面向对象编程OOP：抽象，封装和数据隐藏，多态，继承，可重用性</p>
<p>基本类型：占用空间，解释空间，空间操作</p>
<p>类：类声明（数据成员，成员函数）；类方法定义</p>
<p>不允许非成员函数访问类中的<code>private</code></p>
<p>在类中定义的函数是内联函数</p>
<p>定义类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [Class name]&#123;</span><br><span class="line">    <span class="comment">//default private:</span></span><br><span class="line">    [私有成员函数...]</span><br><span class="line">    [私有数据成员...]</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    [私有成员函数...]</span><br><span class="line">    [私有数据成员...]</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    [公有成员函数...]</span><br><span class="line">    [公有数据成员...]</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    [受保护成员函数...]</span><br><span class="line">    [受保护数据成员...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明和定义类成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">return</span> type] [Class]::[function head]</span><br></pre></td></tr></table></figure>
<h3 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h3><p>声明对象时自动调用，不允许手动调用</p>
<p>没有返回值和类型</p>
<p>存在一个缺省的构造函数，定义为空，但是如果有已定义构造函数缺省构造函数将失效，可以重载一个无参数构造函数态来允许使用缺省构造函数</p>
<p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Class]::[<span class="built_in">Class</span> (,same as <span class="keyword">class</span> name)](parameter <span class="built_in">list</span>(usually m_parameterName),...)</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式</span></span><br><span class="line">[Class] [object name]=[Class](arguments,...);</span><br><span class="line"><span class="comment">//隐式</span></span><br><span class="line">[Class] [object name](arguments,...);</span><br><span class="line"><span class="comment">//指针</span></span><br><span class="line">[Class] [*pointer name of object]=<span class="keyword">new</span> [Class](arguments,...);</span><br></pre></td></tr></table></figure>
<p>可以采用列表初始化，列表为构造函数的参数列表</p>
<p>如果构造函数接受仅一个参数，可以通过赋值的方式初始化对象，但是为了避免出现问题，可以关闭这项特性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Class] [object]=value;</span><br></pre></td></tr></table></figure>
<h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><p>构造函数只接受一个必要参数的态可以用于类型转换，将类型转换为类</p>
<p>重载操作符重载符为类型时可以用于类型转换，将类转换为类型</p>
<p>如果有多个态接受类型或转换类型而来的类型，意味着存在二义性，编译失败</p>
<p><code>explcit</code>将禁止自动类型转换，只允许强制类型转换，在一定程度上避免二义性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐私或显式，向类转换，基于构造函数</span></span><br><span class="line">[<span class="built_in">Class</span> (,same as <span class="keyword">class</span> name)]([type] [parameter],[other parameter with <span class="keyword">default</span> value,...])</span><br><span class="line"><span class="comment">//显式，向类转换，基于构造函数</span></span><br><span class="line"><span class="keyword">explicit</span> [<span class="built_in">Class</span> (,same as <span class="keyword">class</span> name)]([type] [parameter],[other parameter with <span class="keyword">default</span> value,...])</span><br><span class="line"><span class="comment">//向类型转换，基于运算符重载</span></span><br><span class="line"><span class="keyword">operator</span> [<span class="keyword">typename</span>]()</span><br></pre></td></tr></table></figure>
<h3 id="类析构函数"><a href="#类析构函数" class="headerlink" title="类析构函数"></a>类析构函数</h3><p>对象过期时调用（何时过期参考存储持续性），一般不要显式调用</p>
<p>没有参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Class]::[~Class]()</span><br></pre></td></tr></table></figure>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>如果类中包含指向new分配内存的指针，应该复制</p>
<p>对象复制，初始化对象为现有对象时调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Class]::[Class](<span class="type">const</span> [<span class="keyword">class</span>] &amp;)</span><br></pre></td></tr></table></figure>
<p>默认复制为浅复制，成员复制，逐个复制非静态成员，意味着成员指向的内存不会被复制</p>
<p>深复制包括复制指向性内存</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><h3 id="地址运算符"><a href="#地址运算符" class="headerlink" title="地址运算符"></a>地址运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">class</span>]::<span class="keyword">operator</span>[](<span class="type">int</span> [variable]);</span><br></pre></td></tr></table></figure>
<h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a><code>const</code>成员函数</h3><p>允许有无声明const的同名函数同时存在，对于非const类优先调用非const的重载函数</p>
<p>对于声明为常量对象，需要成员函数保证不修改类。否则不允许调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[function head] <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>重载已有的运算符op，包括数组索引符[]，new，new[]，delete，delete[]，x++，++x</p>
<p>不可以重载所有参数都为固有数据类型的情况，以免非预期情况</p>
<p>运算符接受参数数目不会改变，优先级不会改变，嵌套性不会改变</p>
<p>有些不许重载，有些可以重载，有些只能作为成员函数时重载</p>
<p>作为成员函数重载，左侧为类，右侧为参数列表；作为非成员函数重载，操作符的操作数依次出现在参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载运算符函数头</span></span><br><span class="line">[<span class="keyword">return</span> type] <span class="keyword">operator</span> [op]([parament list])</span><br></pre></td></tr></table></figure>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>具有与类相同的访问权限，需要与成员函数一道声明，不可作为成员函数</p>
<p>解决运算符重载时非成员函数希望访问对象的情况</p>
<p>友元函数声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> [function declaration]<span class="comment">//在类内</span></span><br></pre></td></tr></table></figure>
<p>定义不需要<code>friend</code></p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><code>this</code>指针</h3><p>指向本身的指针</p>
<p><code>*this</code>对象本身</p>
<h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>与普通数组差不多</p>
<h3 id="公有常量"><a href="#公有常量" class="headerlink" title="公有常量"></a>公有常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">enum</span>&#123;[<span class="type">const</span> variable name]=[value],...&#125;;	</span><br><span class="line"><span class="comment">//避免名称冲突而定义的类内作用枚举</span></span><br><span class="line"><span class="keyword">enum</span> [<span class="keyword">class</span>|<span class="keyword">struct</span>] [<span class="keyword">enum</span> <span class="title class_">name</span>]&#123;[<span class="type">const</span> variable name]=[value],...&#125;<span class="comment">//定义</span></span><br><span class="line">[<span class="keyword">enum</span>]::[<span class="type">const</span> variable]<span class="comment">//使用</span></span><br><span class="line"><span class="comment">//静态常量</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> [type] [variable]=[value];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>静态成员仅在类声明外才能初始化，但静态常量和静态枚举不受此限制。</p>
<h3 id="动态类"><a href="#动态类" class="headerlink" title="动态类"></a>动态类</h3><p>避免指针对应内存已经释放，导致{使用空内存，释放空内存}</p>
<p>赋值和传参操作会引起类的增加，需要对指针提供额外内存；</p>
<p>函数结束会调用类的析构函数，需要保证析构的内存有效；</p>
<p>负责动态的：</p>
<p>静态成员：记录类的个数，以便对应内存，静态成员仅在类声明外才能初始化，但静态常量和静态枚举不受此限制。</p>
<p>构造函数：多个构造函数时，即使传入单个值也使用<code>new []</code>，即时传入常量值也使用<code>new</code>和<code>strcpy</code>来配合析构函数<code>delete []</code>，对<code>new</code>使用<code>delete[]</code>可能出错 <a href="#构造函数">关于构造函数</a> <a href="#动态分配">关于new</a></p>
<p>折构函数：对应指针使用<code>delete []</code>释放内存 <a href="#折构函数">关于</a></p>
<p>复制构造函数：需要重载并复制内存 <a href="#复制构造函数">关于</a></p>
<p>赋值运算符：重载，考虑赋值给自身的情况，同时复制内存 <a href="#赋值运算符">关于</a></p>
<p>地址运算符：重载，以实现动态内存的索引 <a href="#地址运算符">关于</a></p>
<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><h3 id="派生"><a href="#派生" class="headerlink" title="派生"></a>派生</h3><p>继承基类的实现和接口，需要自己的构造函数和额外成员和成员函数。</p>
<p>公有派生</p>
<p>不能访问基类的私有成员，意味需要调用基类的构造函数</p>
<p>公有派生</p>
<p>公有派生</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [sub_class] : [access-specifier] [parent_class]&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>智能指针模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line">auto_ptr	<span class="comment">//自动指针，带有释放所指向内存的析构函数，但是没有考虑指针共享</span></span><br><span class="line">shared_ptr	<span class="comment">//共享指针，能够让指向同一块内存的多个指针正常访问和删除</span></span><br><span class="line">unique_ptr	<span class="comment">//独特指针，只允许一个指针指向某一块内存，违反则在编译阶段报错，但是编译器应当接受也确实接受指向同一块内存的指针的传递</span></span><br><span class="line">    ptr1=<span class="built_in">fun</span>()&#123;<span class="keyword">return</span> ptr0;&#125;</span><br><span class="line">    ptr1=std::<span class="built_in">move</span>(ptr0)<span class="comment">//指针的传递</span></span><br><span class="line">weak_ptr</span><br><span class="line">scoped_ptr<span class="comment">//boost.lib</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//只允许指向由new分配的内存</span></span><br><span class="line">[[<span class="keyword">auto</span>|shared|unique]_ptr]&lt;[type]&gt; [variable]=<span class="keyword">new</span> [type];</span><br><span class="line"><span class="comment">//只允许指向由new[]分配的内存</span></span><br><span class="line">[unique_ptr]&lt;[type]&gt; [variable]=<span class="keyword">new</span> [type][];</span><br></pre></td></tr></table></figure>
<h2 id="标准模板库STL"><a href="#标准模板库STL" class="headerlink" title="标准模板库STL"></a>标准模板库STL</h2><p>容器、迭代器、函数对象、算法</p>
<p>创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">template</span>]&lt;[type]&gt; [variable name]([count])</span><br></pre></td></tr></table></figure>
<p>迭代器（广义指针）</p>
<p>迭代器使得算法从数据结构中脱离而专注于算法本身的实现，包括了对元素的索引，访问和对超尾的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[stl_class]&lt;[type]&gt;::iterator [iterator name];<span class="comment">//声明</span></span><br><span class="line">[iterator]=[object].<span class="built_in">begin</span>();<span class="comment">//初始化迭代器</span></span><br><span class="line">*[iterator]<span class="comment">//访问对象</span></span><br><span class="line">++[iterator]<span class="comment">//下一个对象迭代</span></span><br><span class="line">[iterator1],[iterator2]<span class="comment">//表示从1到2的之前的区间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ar=iterator1;ar!=iterator2;ar++)</span><br></pre></td></tr></table></figure>
<p>模板类 向量vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;[type]&gt; [variable](count of elements)</span><br><span class="line">    <span class="comment">//一般方法，STL都有</span></span><br><span class="line">    .<span class="built_in">size</span>()</span><br><span class="line">    .<span class="built_in">swap</span>()</span><br><span class="line">    .<span class="built_in">begin</span>()</span><br><span class="line">    .<span class="built_in">end</span>()<span class="comment">//最后一个元素之后的位置</span></span><br><span class="line">    <span class="comment">//特殊方法</span></span><br><span class="line">    .<span class="built_in">push_back</span>(type);<span class="comment">//追加</span></span><br><span class="line">    .<span class="built_in">erase</span>(begin_iterator,end_iterator+<span class="number">1</span>);<span class="comment">//删除</span></span><br><span class="line">    .<span class="built_in">insert</span>(pos_target_iterator,begin_source_iterator,end_source_iterator+<span class="number">1</span>);<span class="comment">//插入</span></span><br><span class="line">    <span class="comment">//非成员方法</span></span><br><span class="line">    .for_each(begin_iterator,end_iterator+<span class="number">1</span>,<span class="type">void</span>*(ReadOnlyFunction)(type));<span class="comment">//逐元素操作</span></span><br><span class="line">	.<span class="keyword">for</span>(type [tmp_variable]:[stl_variable])&#123;</span><br><span class="line">        <span class="comment">//不同于for_each，能够引用x从而修改stl_variable的成员</span></span><br><span class="line">    &#125;<span class="comment">//范围for，针对stl_variable逐元素操作//C++11</span></span><br><span class="line">    .<span class="built_in">Random_shuffle</span>(begin_iterator,end_iterator+<span class="number">1</span>);<span class="comment">//随机重排</span></span><br><span class="line">	.<span class="built_in">sort</span>(begin_iterator,end_iterator+<span class="number">1</span>)<span class="comment">//内排序，采用成员函数operate&lt;()升序</span></span><br><span class="line">    .<span class="built_in">sort</span>(begin_iterator,end_iterator+<span class="number">1</span>,<span class="type">bool</span>*(SortFunction)(type&amp;,type&amp;))<span class="comment">//内排序，采用成员函数operate&lt;()升序</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/C++/" data-id="cl430wi3v0002akfcd7ez8ata" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Android" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/Android/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.830Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>res/</p>
<p><resources_directories>{<br>​    animator/<br>​    anim/<br>​    color/<br>​    drawable/<br>​    mipmap/<br>​    layout/<br>​    menu/<br>​    raw/<br>​    values/<br>​    xml/<br>​    font/<br>}</p>
<p><config_qualifier>{<br>    -mcc[移动设备国家代码]<br>    -mcn[移动设备网络代码]<br>}</p>
<p>Android系统<br>基于Linux的开源系统，最初由Andy Rubin开发<br>Phone，Tablet，Watch，Glasses，TV，智能家居<br>Android，iOS基于Objective-C开发<br>1.系统架构<br>01.Linux内核层<br>驱动和电源管理<br>{显示，相机，蓝牙， 闪存，进程间通信，USB，键盘，WiFi，音频}驱动+电源管理<br>02.类库层（C/C++）<br>{，多媒体框架，SQLite数据库，OpenGL|ES/SGL—3D/2D图形，SSL—安全通信协议，WebKit—浏览器内核，libc—C语言}库<br>03.Android运行时<br>JVM升级自用版DVM虚拟机，jre核心库<br>04.应用框架层（JAVA）<br>{Activity界面，窗口，内容提供者，视图系统，通知栏，包，电话，资源，定位，XMPP即时通讯}管理<br>05.应用层<br>桌面，联系人Contacts，电话，浏览器，……<br>**Dalvik DVM相对于JVM：基于寄存器而非栈，执行压缩class压缩后的.dex文件，每个应用对应单独虚拟机和单独进程</p>
<pre><code>2.目录结构
.gradle自动生成，打包时可删除
.idea自动生
app
    build生成的文件
    src
        main
    lib其他jar包
gradle构建器
    .gitignore          版本控制git排除目录
    build.gradle        全局构建脚本
    gradle.properties   全局配置
    gradlew             脚本Mac，Linus
    gradlew.bat         脚本Windows
    local.properties    路径SDK
    settings.gradle     指定引入模块
External Libraries第三方库，依赖文件
</code></pre><p>3组件<br>视图大小用dp，文字大小用sp<br>调试Log.e(Tag,[“msg”])<br>组件对象 [View类名] [组件对象名]=findViewById(R.id.[id]);<br>01TextView<br>文字阴影<br>shadowColor<br>shadowRadius<br>shadowDx<br>shadowDy<br>跑马灯<br>text=[超长文本]<br>singleLine=true<br>ellipsize=marquee滚动显示<br>marqueeRepeatLimit滚动次数限制<br>focusable=true允许获取焦点<br>focusableInTouchMode=true允许获取焦点</p>
<p>添加<requestFocus/>子项得到焦点<br>或者，重写TextView类<br>02按钮背景</p>
<p><Button><br>background=[颜色]，需要设置res&gt;values&gt;themes.xml&gt;style&gt;parent=.[object]+”.Bridge”<br>或者，background=[选择器]，在res&gt;drawable中新建选择器，导入图片，建立<item>，drawable=[导入的图片]，[状态/state_pressed/]=true，从而使得背景根据按钮状态改变<br>且，backgroundTint=[颜色选择器]，在res中新建文件夹color，新建选择器，建立<item>，drawable=[颜色]，[状态/state_pressed/]=true，从而使得颜色根据按钮状态改变<br>foreground，会覆盖文字<br>按钮事件处理<br>onCreate函数中：￥[组件对象].setOn[Click/Touch/LongClick]Listener函数内回调函数写命令，当回调函数返回true时，按钮事件不会触发新的回调函数，Touch代表触摸移动，Touch中event.getAction[down=0，move=2，up=1]，LongClick代表长按，Click代表松手<br>或者，￥onClick=[方法名]，回调函数写命令，会替代setOnClick</p>
<p>03EditText<br>hint输入提示<br>inputType输入类型<br>drawable[Direction]=[]指定方位处的图片<br>background=[.9图形]<br>￥获取输入 [组件对象].getText().toString()</p>
<p>04ImageView<br>src图片资源<br>scaleType=fitStart长边缩放左上角/默认fitCenter长边缩放居中/fitEnd长边缩放右下角/center原图居中/fitXY拉伸铺满/centerCrop窄边缩放左上角/CenterInside保证在内否则缩放/matrix原图左上角<br>adjustViewBounds=true允许0指定最大宽高<br>maxHeight/maxWidth指定最大宽高</p>
<p>05ProgressBar<br>style<br>max最大值<br>progress设定当前值<br>indeterminate设置进度表示为加载状态还是确定的进度<br>￥隐藏消失 [组件对象].setVisibility(View.GONE/View.VISIBLE);<br>￥获取进度 [组件对象].getProgress();</p>
<p>06Notification<br>￥NotificationManager [通知管理器对象名]=(NotificationManager)getSystemService(NOTIFICATION<em>SERVICE);<br>￥if(Build.VERSION.SDK_INT &gt;=Build.VERSION_CODES.o){//Android8.0以上，应当设置通知渠道<br>￥    NotificationChannel [渠道对象名] =new NotificationChannel([通知渠道id],”[通知名]”,[重要性￥IMPORTANCE</em>[NONE关闭通知/MIN开启通知/LOW显示在状态栏/DEFAULT有提示音/HIGH弹出显示]]);<br>￥    [通知管理器对象].createNotificationChannel(channel);<br>}<br>￥Notification [通知对象名] = new NotificationCompat.Builder(this,[通知渠道id]).build(); </p>
<p>07ToolBar<br>？在LinerLayout布局中；可以有多个ToolBar<br>res&gt;values&gt;themes.xml&gt;style&gt;parent=.[object]To”.NoActionBar”</p>
<p><android.appcompat.widget.Toolbar><br>background<br>layout_windth=”match_parent”<br>layout_height=”?attr/actionBarSize”<br>gravity和layout_gravity共同居中效果<br>app:navigationIcon导航图标<br>app:logo图标<br>app:title标题<br>app:titleTextColor标题颜色<br>app:titleMarginStart标题左边距<br>app:subtitle位于主标题下方与主标题起始齐的副标题<br>app:subtitleTextColor副标题颜色</p>
<p>￥注意包的导入androidx，在OnCreate函数中，[组件对象].setNavigationOnClickListener函数内回调点击导航图标的函数，<br>￥[组件对象].set[layout_meter]函数可指定Toolbar的属性</p>
<p>08AlertDialog<br>￥AlertDialog.Builder [对话框构建器]=new AlertDialog.Builder(this);<br>￥[对话框构建器].setIcon([图片资源索引对象])<br>.setTitle([标题字符串])<br>.setMessage([消息字符串])<br>.setPositiveButton([确定按钮名称字符串],[创建新的dialogInterface回调函数])<br>.setNeutraButton([中间按钮名称字符串],[创建新的dialogInterface回调函数])<br>.setNegativeButton([取消按钮名称字符串],[创建新的dialogInterface回调函数])<br>.setView([对话框内布局View])    采用View [对话框内布局View]=getLayoutInflater().inflate([布局资源索引对象],null);获取布局对象<br>……<br>.create()<br>.show()</p>
<p>09PopupWindow弹窗</p>
<p>PopupWindow [] = new PopWindow([布局View],<em>[宽ViewGroup.LayoutParams.WRAP_CONTENT],</em>[高ViewGroup.LayoutParams.WRAP_CONTENT],<em>*[在点击其他位置时退出true])<br>.dismiss()关闭<br>.setFocusable()<br>.setBackgroundDrawable()背景图片<br>.setAnimationStyle()加载动画<br>.setTouchable()<br>.setOutsideTouchable()<br>.showAsDropDown([上方布局参考],</em>[x方向偏移view.getWidth()],*[y方向偏移view.getHeight()])</p>
<p>11.<br>LinearLayout<br>RelativeLayout<br>FrameLayout帧布局，从父容器左上角开始，每次绘制堆叠在表层<br>android:foreground前景图片<br>android:foregroundGravity前景图片位置<br>TableLayout表格布局，<br>android:collapseColumns指定被隐藏的列<br>android:stretchColumns指定允许被拉伸的列<br>android:shrinkColumns指定允许被压缩的列</p>
<p><TableRow>同一行内的布局<br>android:layout_column指定子控件显示在第几列<br>android:layout_span指定用多少列来显示
</TableRow><br>GridLayout网格布局，相对于表格布局允许行合并<br>android:orientation水平或垂直显示<br>android:columnCount最多显示列数<br>android:rowCount最多显示行数<br>、、子控件属性<br>android:layout_column指定子控件显示在第几列<br>android:layout_columnSpan指定用多少列来显示，结合android:layout_gravity实现效果<br>android:layout_columnWeight横向剩余空间分配权重<br>android:layout_row指定子控件显示在第几列<br>android:layout_rowSpan指定用多少列来显示<br>android:layout_rowWeight横向剩余空间分配权重<br>ConstraintLayout，约束布局，参考线，边距，填充，推导约束，清除约束，没有约束时等效帧布局</p>
<p>ListView</p>
<p>程序结构:<br>src包(源码)<br>gen包(自动生成的)<br>res包(资源文件)<br>       drawable(图片文件夹)<br>       layout(布局文件夹)<br>       values(常量文件夹)<br>AndroidManifest.xml(功能清单配置文件)<br>assets(资产文件)<br>bin(包含)<br>libs</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/Android/" data-id="cl430wi3a0001akfcadgkh3r1" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-UWP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/UWP/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.808Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Content.Tostring()</p>
<p>dir=(Right|Left|VerticalCenter|HorizontalCenter|Up|Bottom)<br>如下优先级逐次降低的方式定义相对布局为贴近页面，贴近元素，对照元素</p>
<p><RelativePanel><br>    &lt;[Item] RelativePanel.Align[dir]WithPanel=”[boolean]”/&gt;<br>    &lt;[Item] RelativePanel.Align[dir]With=”[ItemName]”/&gt;<br>    &lt;[Item] RelativePanel.[dir]Of=”[ItemName]”/&gt;<br>    &lt;[Panel]&gt;
</RelativePanel>  </p>
<hr>
<p>mode=(Inline|CompactInline|Overlay|CompactOverlay)<br>作为抽屉界面，含有简略和详细两种布局</p>
<p><SplitView DisplayMode="[mode]" CompactPaneLength="" OpenPaneLength=""><br>    <SplitView.Pane><br>        &lt;[Item]/&gt;<br>        …<br>    &lt;/SplitView.Pane&gt;<br>    <SplitView.Content><br>        &lt;[Item]/&gt;<br>        …<br>    &lt;/SplitView.Content&gt;<br>&lt;/SpiltView&gt;<br>//切换布局<br>fun(){<br>    [SplitViewName].IsPaneOpen=[Boolean]<br>}</p>
<hr>
<p>断点：应用窗口尺寸：小（-640）、中（641-1007）、大（1008-）</p>
<p>有效像素epx、ep、px</p>
<p>若要在运行时获取元素的大小，请使用只读 ActualHeight 和 ActualWidth 属性，而不是 Height 和 Width 。</p>
<hr>
<p>导航Navigation：<br>FrameObject：：Page</p>
<p>//导向指定页<br>[Frame].Navigate(typeof([PageName],[自己指定的参数]));<br>protected override void OnNavigatedTo(NavigationEventArgs e){<br>    //导向后获取数据<br>}<br>//向前导航<br>if([Frame].CanGoBack){<br>    [Frame].GoBack();<br>}<br>//向后导航<br>if([Frame].CanGoForward){<br>    [Frame].Forward();<br>}</p>
<hr>
<p>HyperlinkButton<br>》NavigateUri=””</p>
<hr>
<p>CheckBox<br>》Tapped=@<br>《&amp;IsChecked<br>》</p>
<p>RadioButton<br>》GroupName=””<br>》Checked=@</p>
<p>ComboBox<br>》SelectionChanged=@fun<br>》》comboBoxItem<br>    》IsSelected<br>《private void fun(object sender,SelectionChangedEventArgs e){<br>    var combo=(ComboBox)sender;<br>    var item=(ComboBoxItem)combo.selectedItem;<br>}</p>
<p>ListBox<br>》SelectionMode=”Single|Multiple”<br>》SelectionChanged=@fun<br>《<br>var selectedItems=[ListBoxName].Items.Cast<ListBoxItem>().where(p=&gt;p.IsSelected).Select(t=&gt;t.Content.ToString()).ToArray();<br>text=string.Join(“[break]”,selectedItems)</p>
<p>Image<br>》Source=”filepath”<br>》Stretch=”None原尺寸|Fill填充|Uniform等比填充|UinformToFill”</p>
<p>ToggleButton<br>》IsThreeState=”True|False”，null|1|0<br>《&amp;IsChecked</p>
<p>ToggleSwitch<br>》《offContent<br>》《OnContent</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/UWP/" data-id="cl430wi4m000bakfc5wjdcc5t" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ProcessService" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/ProcessService/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.776Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>进程 Process</p>
<p>僵尸进程 zombie</p>
<p>进程序号 PID</p>
<p>命令</p>
<ul>
<li>ps</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//主进程和子进程，共享的执行语句和独立的内存结构</span></span><br><span class="line">	<span class="comment">//pid为进程id</span></span><br><span class="line">	<span class="comment">//pid为0</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/ProcessService/" data-id="cl430wi4h000aakfc2sf30w1k" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OpenGL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/OpenGL/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.762Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><pre class="mermaid">graph TD;
GUI-->Windows & Android & Web & openGL & Hyper;
Windows--> Win32 & .NET & WinUI3 & UWP;
WinUI3-->MAUI;
Win32-->WinForm & WPF;
UWP-->WinUI2 & React_Native;
openGL-->openGLES & webGL & Vulkan;
Android-->Java & Kotlin & Flutter;
Web-->React_Native & Vue & Angular & Electron;
Hyper.->MAUI & Electron & Flutter & React_Native & QT;</pre>

<h3 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h3><p>状态机，流，<br>glfw窗口管理<br>glew函数接口转换<br>顶点缓冲区<br>glGenBuffer@count%out_id<br>glBindBuffer@type%id<br>glBufferData@type%size%buffer<br>着色器<br>glCreateProgram<br>顶点，片段/像素，几何，细分曲面<br>顶点属性<br>位置<br>纹理坐标<br>法线<br>glDrawArrays<br>glDrawElements<br>glVertexAttrPointer<br>glVertexAttrPointer</p>
<h3 id="对象Object"><a href="#对象Object" class="headerlink" title="对象Object"></a>对象Object</h3><p>存储数据和状态</p>
<h4 id="顶点缓冲对象：Vertex-Buffer-Object，VBO"><a href="#顶点缓冲对象：Vertex-Buffer-Object，VBO" class="headerlink" title="顶点缓冲对象：Vertex Buffer Object，VBO"></a>顶点缓冲对象：Vertex Buffer Object，VBO</h4><p>顶点属性从VBO中获得，使用哪个VBO取决于哪个VBO被绑定到GL_ARRAY_BUFFER</p>
<p>在GPU上创建内存用于储存我们的顶点数据，通过顶点缓冲对象管理这个内存⚙通过一次性发送大量顶点数据加速</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glGenBuffers([count of buffers], &amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(float) * count_number, vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<h4 id="顶点数组对象：Vertex-Array-Object，VAO"><a href="#顶点数组对象：Vertex-Array-Object，VAO" class="headerlink" title="顶点数组对象：Vertex Array Object，VAO"></a>顶点数组对象：Vertex Array Object，VAO</h4><p><strong>VBO</strong>可能会有多个，但<strong>VAO</strong>只有一个</p>
<p><strong>VAO</strong>就是为了向GPU解释顶点数据</p>
<p>绑定VAO，以告知OpenGL程序该使用这个VAO来对VBO做出解释， 然后，绑定每个VBO后，向这个VBO中写入数据，并告知VAO该如何解释这个VBO的信息，针对不同的VBO，VAO能够以不同的方式解释信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer([start], [attr count of each vertex], [type:GL_FLOAT], [normalize:GL_FALSE], [strike in byte], [pointer of buffer,(<span class="type">void</span>*)<span class="number">0</span> <span class="keyword">if</span> VBO]);</span><br><span class="line">glEnableVertexAttribArray([index]);</span><br></pre></td></tr></table></figure>
<p>管理</p>
<h4 id="索引缓冲对象：Element-Buffer-Object，EBO或Index-Buffer-Object，IBO"><a href="#索引缓冲对象：Element-Buffer-Object，EBO或Index-Buffer-Object，IBO" class="headerlink" title="索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO"></a>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</h4><h3 id="着色器Shader"><a href="#着色器Shader" class="headerlink" title="着色器Shader"></a>着色器Shader</h3><h4 id="图形渲染管线-Graphics-Pipeline"><a href="#图形渲染管线-Graphics-Pipeline" class="headerlink" title="图形渲染管线 Graphics Pipeline"></a>图形渲染管线 Graphics Pipeline</h4><p>内含许多着色器 Shader，用OpenGL着色器语言 OpenGL Shading Language, GLSL 写成</p>
<p><img src="https://learnopengl-cn.github.io/img/01/04/pipeline.png" alt="img"></p>
<p>3D坐标转为2D坐标转像素</p>
<p>⭐顶点着色器(Vertex Shader)：3D坐标转为标准化设备3D坐标</p>
<p>➰图元装配(Primitive Assembly)阶段：将顶点着色器输出的所有顶点装配成指定图元的形状</p>
<p>➰几何着色器(Geometry Shader)：几何着色器把图元(Primitive)[指定顶点数据的渲染类型（点、三角形、线[GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP]）]形式的一系列顶点的集合作为输入，通过产生新顶点构造出新的图元来生成其他形状。</p>
<p>➰光栅化阶段(Rasterization Stage)：这里它会把图元映射为最终屏幕上相应的像素，生成片段(Fragment)[渲染一个像素所需的所有数据]，执行裁切(Clipping)[丢弃超出视图以外的所有像素]</p>
<p>⭐片段着色器(Fragment Shader)：计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。包含3D场景的数据（比如光照、阴影、光的颜色等等）</p>
<p>➰Alpha测试和混合(Blending)阶段：根据深度和模板(Stencil)值决定像素是否应该丢弃；根据alpha值(透明度)对物体进行混合(Blend)。</p>
<p>仅标准化设备坐标(Normalized Device Coordinates,NDC)[3D坐标在3个轴上都为-1.0到1.0的范围内]范围内的坐标才呈现在屏幕上。<img src="https://learnopengl-cn.github.io/img/01/04/ndc.png" alt="NDC"></p>
<p>通过glViewport函数提供的数据进行视口变换(Viewport Transform)变换为屏幕空间坐标(Screen-space Coordinates)</p>
<p>GLSL中一个向量有最多4个分量，<code>vec.x</code>、<code>vec.y</code>、<code>vec.z</code>和<code>vec.w</code>。<code>vec.w</code>用于透视除法(Perspective Division)</p>
<p>颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量 RGBA。颜色每个分量的强度在0.0到1.0之间。</p>
<h3 id="纹理Texture"><a href="#纹理Texture" class="headerlink" title="纹理Texture"></a>纹理Texture</h3><p>图片和数据，映射map到物体上</p>
<h4 id="纹理坐标Texture-Coordinate"><a href="#纹理坐标Texture-Coordinate" class="headerlink" title="纹理坐标Texture Coordinate"></a>纹理坐标Texture Coordinate</h4><p>用来标明该从纹理图像的哪个部分采样Sampling，之后在图形的其它片段上进行片段插值Fragment Interpolation。</p>
<p>纹理坐标起始于(0, 0)左下角，终止于(1, 1)右上角。<img src="https://learnopengl-cn.github.io/img/01/06/tex_coords.png" alt="img"></p>
<h4 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h4><p>纹理坐标设置在范围之外会发生什么</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">环绕方式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_REPEAT</td>
<td style="text-align:left">对纹理的默认行为。重复纹理图像。</td>
</tr>
<tr>
<td style="text-align:left">GL_MIRRORED_REPEAT</td>
<td style="text-align:left">和GL_REPEAT一样，但每次重复图片是镜像放置的。</td>
</tr>
<tr>
<td style="text-align:left">GL_CLAMP_TO_EDGE</td>
<td style="text-align:left">纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>
</tr>
<tr>
<td style="text-align:left">GL_CLAMP_TO_BORDER</td>
<td style="text-align:left">超出的坐标为用户指定的边缘颜色。</td>
</tr>
</tbody>
</table>
</div>
<p>单独设置坐标轴纹理环绕方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对坐标轴指定环绕方式</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_【S|T|R】, 【环绕方式】); </span><br><span class="line"><span class="comment">//指定边缘颜色</span></span><br><span class="line"><span class="type">float</span> borderColor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;; <span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure>
<h4 id="纹理过滤Texture-Filtering"><a href="#纹理过滤Texture-Filtering" class="headerlink" title="纹理过滤Texture Filtering"></a>纹理过滤Texture Filtering</h4><p>纹理坐标不依赖于分辨率Resolution，它可以是任意浮点值</p>
<p>所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel)映射到纹理坐标。</p>
<p>针对物体大于纹理分辨率的情况产生纹理过滤</p>
<p>纹理过滤有很多个选项，最重要的两种：</p>
<ol>
<li>GL_NEAREST：邻近过滤，Nearest Neighbor Filtering，像素风</li>
<li>GL_LINEAR：线性过滤，(Bi)linear Filtering，模糊化</li>
</ol>
<p>可以在放大(Magnify)和缩小(Minify)的时候设置纹理过滤的选项</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>
<h4 id="多级渐远纹理Mipmap"><a href="#多级渐远纹理Mipmap" class="headerlink" title="多级渐远纹理Mipmap"></a>多级渐远纹理Mipmap</h4><p>从高分辨率纹理中为小片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色，同时在在小物体上这会产生不真实的感觉</p>
<p>多级渐远纹理是一系列的纹理图像，后一个纹理图像是前一个的二分之一。</p>
<p>距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。</p>
<p>多级渐远纹理主要是使用在纹理被缩小的情况下的，纹理放大不会使用多级渐远纹理。</p>
<p><img src="https://learnopengl-cn.github.io/img/01/06/mipmaps.png" alt="img"></p>
<p>切换多级渐远纹理级别时也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">过滤方式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_NEAREST_MIPMAP_NEAREST</td>
<td style="text-align:left">使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>
</tr>
<tr>
<td style="text-align:left">GL_LINEAR_MIPMAP_NEAREST</td>
<td style="text-align:left">使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>
</tr>
<tr>
<td style="text-align:left">GL_NEAREST_MIPMAP_LINEAR</td>
<td style="text-align:left">在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>
</tr>
<tr>
<td style="text-align:left">GL_LINEAR_MIPMAP_LINEAR</td>
<td style="text-align:left">在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩小使用的纹理，多级渐远线性</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line"><span class="comment">//放大使用的纹理，线性</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/OpenGL/" data-id="cl430wi4f0009akfchleecvoa" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/MySQL/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.743Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>SQL</p>
<p>数据库</p>
<p>SQL 结构化数据查询语言</p>
<p>大小写不敏感<br>数据操作语言 (DML)：查询，更新<br>数据定义语言 (DDL)：修改表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">USE 库名称;</span><br><span class="line"><span class="keyword">SET</span> names utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">USE 库名称;</span><br><span class="line"><span class="keyword">SET</span> names utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表</p>
<p>查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM [表名称];</span><br><span class="line">#返回列表</span><br><span class="line">SELECT [列名称],... FROM [表名称];</span><br><span class="line">#返回部分列表</span><br><span class="line">SELECT DISTINCT [列名称] FROM [表名称];</span><br><span class="line">#返回集合</span><br><span class="line">SELECT [列名称] FROM [表名称] WHERE [条件];</span><br><span class="line">#返回符合条件的</span><br><span class="line">#$[SELECT * FROM [表名称] WHERE [左条件] AND|OR [右条件];]</span><br><span class="line">#$[SELECT * FROM [表名称] WHERE (或左条件 OR 或右条件) AND 与右条件;]</span><br><span class="line">#条件：列 运算符 值：FirstName=&#x27;Thomas&#x27;   Year&gt;2002#使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。</span><br><span class="line">SELECT 列名称,... FROM 表名称 ORDER BY 列名称 ASC|DESC,...; #ASC升序，DESC降序</span><br><span class="line">#依照序列返回</span><br></pre></td></tr></table></figure>
<p>增</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名称 VALUES (值,....);</span><br><span class="line">INSERT INTO table_name (列,...) VALUES (值,....);</span><br></pre></td></tr></table></figure>
<p>改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名称 SET 列名称 = 值,... WHERE 条件 ;</span><br></pre></td></tr></table></figure>
<p>删</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名称;</span><br><span class="line">DELETE * FROM 表名称;</span><br><span class="line">DELETE FROM 表名称 WHERE 列名称 = 值;</span><br></pre></td></tr></table></figure>
<p>限定</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TOP 数目 (<span class="keyword">PERCENT</span>)</span><br><span class="line">#限定返回的数目</span><br><span class="line">#$[<span class="keyword">SELECT</span> TOP <span class="number">2</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons]</span><br><span class="line">#$[<span class="keyword">SELECT</span> TOP <span class="number">50</span> <span class="keyword">PERCENT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons]</span><br><span class="line">LIMIT 数目</span><br><span class="line">#限定返回的数目</span><br><span class="line">#$[<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons LIMIT <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> 别名</span><br><span class="line">#指定别名</span><br><span class="line">#$[<span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name <span class="keyword">FROM</span> table_name]</span><br><span class="line">#$[<span class="keyword">SELECT</span> po.OrderID, p.LastName, p.FirstName <span class="keyword">FROM</span> Persons <span class="keyword">AS</span> p, Product_Orders <span class="keyword">AS</span> po <span class="keyword">WHERE</span> p.LastName<span class="operator">=</span><span class="string">&#x27;Adams&#x27;</span> <span class="keyword">AND</span> p.FirstName<span class="operator">=</span><span class="string">&#x27;John&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>where运算符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left">BETWEEN</td>
<td style="text-align:left">在某个范围内</td>
</tr>
<tr>
<td style="text-align:left">LIKE</td>
<td style="text-align:left">搜索某种模式</td>
</tr>
<tr>
<td style="text-align:left">AND</td>
<td style="text-align:left">条件与</td>
</tr>
<tr>
<td style="text-align:left">OR</td>
<td style="text-align:left">条件或</td>
</tr>
<tr>
<td style="text-align:left">NOT</td>
<td style="text-align:left">条件取反</td>
</tr>
<tr>
<td style="text-align:left">LIKE 模式</td>
<td style="text-align:left">匹配模式</td>
</tr>
<tr>
<td style="text-align:left">IN (值,…)</td>
<td style="text-align:left">在值中</td>
</tr>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<p>通配符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">通配符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">代表零个或多个字符</td>
</tr>
<tr>
<td style="text-align:left">_</td>
<td style="text-align:left">仅替代一个字符</td>
</tr>
<tr>
<td style="text-align:left">[charlist]</td>
<td style="text-align:left">字符列中的任何单一字符</td>
</tr>
<tr>
<td style="text-align:left"><sup><a href="#fn_charlist" id="reffn_charlist">charlist</a></sup>或者[!charlist]</td>
<td style="text-align:left">不在字符列中的任何单一字符</td>
</tr>
</tbody>
</table>
</div>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/MySQL/" data-id="cl430wi4d0008akfcdz7ih5zk" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Local file system" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/Local%20file%20system/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.733Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Directory Management</p>
<h3 id="hardlink"><a href="#hardlink" class="headerlink" title="hardlink"></a>hardlink</h3><p>链接到同一卷中单个文件</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-createhardlinka"><strong>CreateHardLink</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-deletefilea"><strong>DeleteFile</strong></a> </p>
<h3 id="junctions"><a href="#junctions" class="headerlink" title="junctions"></a>junctions</h3><p>软链接，本地卷中的文件</p>
<p>通过重解析点实现</p>
<p>symbol link</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><h3 id="★reparse-points"><a href="#★reparse-points" class="headerlink" title="★reparse points"></a>★reparse points</h3><p>比照reparse tag查找与data format identified关联的file system filter，找到后将按照reparse data处理数据</p>
<p>适用于文件不在物理池存储，而仍要在文件系统中留有存根</p>
<h3 id="hard-disk"><a href="#hard-disk" class="headerlink" title="hard disk"></a>hard disk</h3><p>platter盘片</p>
<p>head盘面</p>
<p>track磁道 盘面上的圆环</p>
<p>cylinder柱面 上下一组盘面同一位置的一组磁道</p>
<p>sector扇区 磁道 一段圆弧 最小可寻址单位</p>
<h4 id="基本磁盘"><a href="#基本磁盘" class="headerlink" title="基本磁盘"></a>基本磁盘</h4><p>常用，支持USB驱动器</p>
<ul>
<li>创建和删除主分区和扩展分区。</li>
<li>在扩展分区中创建和删除逻辑驱动器。</li>
<li>格式化分区并将其标记为活动。</li>
</ul>
<h4 id="动态磁盘"><a href="#动态磁盘" class="headerlink" title="动态磁盘"></a>动态磁盘</h4><p>只推荐作为镜像引导卷</p>
<p>允许卷在一个或多个物理磁盘上具有不连续的扩展区</p>
<p>依赖于逻辑磁盘管理器 (LDM) 和虚拟磁盘服务 (VDS)</p>
<p>MBR结构中只允许一个主分区（ LDM 分区），不允许扩展分区，并且在磁盘末尾有一个隐藏分区用于 LDM 数据库</p>
<ul>
<li>创建和删除简单、跨区、条带化、镜像和 RAID-5 卷。</li>
<li>扩展简单或跨区卷。</li>
<li>从镜像卷中删除镜像或将镜像卷分成两个卷。</li>
<li>修复镜像或 RAID-5 卷。</li>
<li>重新激活丢失或脱机的磁盘。</li>
</ul>
<h3 id="partitions分区"><a href="#partitions分区" class="headerlink" title="partitions分区"></a>partitions分区</h3><p>逻辑结构</p>
<h4 id="MBR主引导记录Master-Boot-Record"><a href="#MBR主引导记录Master-Boot-Record" class="headerlink" title="MBR主引导记录Master Boot Record"></a>MBR主引导记录Master Boot Record</h4><p>联系磁盘的第一个物理扇区</p>
<p> MBR 分区方案在基本磁盘上创建最多四个分区：四个主分区，或三个主分区和一个扩展分区</p>
<p>扩展分区可以包含一个或多个逻辑驱动器</p>
<p>扩展分区可能位于也可能不在磁盘的末尾，但对于每个逻辑驱动器，它始终是单个连续空间</p>
<ul>
<li>A boot program (up to 442 bytes in size)</li>
<li>A disk signature (a unique 4-byte number)</li>
<li>A partition table (up to four entries)</li>
<li>An end-of-MBR marker (always 0x55AA)</li>
</ul>
<p><img src="https://docs.microsoft.com/en-us/windows/win32/fileio/images/basic-mbr.png" alt="使用 mbr 在基本磁盘上的三个主分区和一个扩展分区"><img src="https://docs.microsoft.com/en-us/windows/win32/fileio/images/basic-gpt.png" alt="gpt布局"></p>
<h4 id="GPT-GUID-Partition-Table"><a href="#GPT-GUID-Partition-Table" class="headerlink" title="GPT GUID Partition Table"></a>GPT GUID Partition Table</h4><p>基本磁盘最多可以有 128 个主分区，而动态磁盘将有一个 LDM 分区</p>
<p>允许大于 2 TB 的分区。</p>
<p>增加了分区表的复制和循环冗余校验 (CRC) 保护的可靠性。</p>
<p>支持由原始设备制造商 (OEM)、独立软件供应商 (ISV) 和其他操作系统定义的其他分区类型<strong>GUID 。</strong></p>
<p>保护性 MBR 区域存在于 GPT 分区布局中，以便与在 MBR 上运行的磁盘管理实用程序向后兼容。</p>
<h3 id="file文件"><a href="#file文件" class="headerlink" title="file文件"></a>file文件</h3><h4 id="file-stream"><a href="#file-stream" class="headerlink" title="file stream"></a>file stream</h4><p>​    allocation size</p>
<p>​     actual size</p>
<p>​    valid data length (VDL)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Stream Type</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">::$ATTRIBUTE_LIST</td>
<td style="text-align:left">Contains a list of all attributes that make up the file and identifies where each attribute is located.</td>
</tr>
<tr>
<td style="text-align:left">::$BITMAP</td>
<td style="text-align:left">A bitmap used by indexes to manage the b-tree free space for a directory. The b-tree is managed in 4 KB chunks (regardless of cluster size) and this is used to manage the allocation of these chunks. This stream type is present on every directory.</td>
</tr>
<tr>
<td style="text-align:left">::$DATA</td>
<td style="text-align:left">Data stream. The default data stream has no name. Data streams can be enumerated using the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-findfirststreamw"><strong>FindFirstStreamW</strong></a> and <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-findnextstreamw"><strong>FindNextStreamW</strong></a> functions.</td>
</tr>
<tr>
<td style="text-align:left">::$EA</td>
<td style="text-align:left">Contains Extended Attributes data.</td>
</tr>
<tr>
<td style="text-align:left">::$EA_INFORMATION</td>
<td style="text-align:left">Contains support information about the Extended Attributes.</td>
</tr>
<tr>
<td style="text-align:left">::$FILE_NAME</td>
<td style="text-align:left">The name of the file, in Unicode characters. This includes the short name of the file as well as any hard links.</td>
</tr>
<tr>
<td style="text-align:left">::$INDEX_ALLOCATION</td>
<td style="text-align:left">The stream type of a directory. Used to implement filename allocation for large directories. This stream represents the directory itself and contains all of the data of the directory. Changes to streams of this type are logged to the NTFS change journal. The default stream name of an $INDEX_ALLOCATION stream type is $I30 so “<em>DirName</em>“, “<em>DirName</em>::$INDEX_ALLOCATION”, and “<em>DirName</em>:$I30:$INDEX_ALLOCATION” are all equivalent.</td>
</tr>
<tr>
<td style="text-align:left">::$INDEX_ROOT</td>
<td style="text-align:left">This stream represents root of the b-tree of an index. This stream type is present on every directory.</td>
</tr>
<tr>
<td style="text-align:left">::$LOGGED_UTILITY_STREAM</td>
<td style="text-align:left">Similar to ::$DATA but operations are logged to the NTFS change journal. Used by EFS and <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/fileio/transactional-ntfs-portal">Transactional NTFS (TxF)</a>. The “:<em>StreamName</em>:$<em>StreamType</em>“ pair for EFS is “:$EFS:$LOGGED_UTILITY_STREAM” and for TxF is “:$TXF_DATA:$LOGGED_UTILITY_STREAM”.</td>
</tr>
<tr>
<td style="text-align:left">::$OBJECT_ID</td>
<td style="text-align:left">An 16-byte ID used to identify the file for the link-tracking service.</td>
</tr>
<tr>
<td style="text-align:left">::$REPARSE_POINT</td>
<td style="text-align:left">The <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/fileio/reparse-points">reparse point</a> data.</td>
</tr>
</tbody>
</table>
</div>
<h4 id="File-Objects"><a href="#File-Objects" class="headerlink" title="File Objects"></a>File Objects</h4><p>​    File name</p>
<p>​    Current byte offset</p>
<p>​    Share mode</p>
<p>​    I/O mode</p>
<p>​    Pointer to device object</p>
<p>​    Pointer to the volume parameter block, or <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_vpb"><strong>VPB</strong></a> </p>
<p>​    Pointer to section object pointers</p>
<p>​    Pointer to private cache map</p>
<h4 id="File-Handles文件句柄"><a href="#File-Handles文件句柄" class="headerlink" title="File Handles文件句柄"></a>File Handles文件句柄</h4><p>通常是进程唯一且私有的</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-createfilea"><strong>CreateFile</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/handleapi/nf-handleapi-closehandle"><strong>CloseHandle</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle"><strong>DuplicateHandle</strong></a> </p>
<h4 id="File-Pointers文件指针"><a href="#File-Pointers文件指针" class="headerlink" title="File Pointers文件指针"></a>File Pointers文件指针</h4><p>指向要读写的文件位置，打开默认为0，每次读写后移，至文件尾不再移动</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer"><strong>SetFilePointer</strong></a> 设置文件指针位置</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-setendoffile"><strong>SetEndOfFile</strong></a> 设置指针位置为文件结束位置</p>
<h4 id="Clusters-and-Extents簇和范围"><a href="#Clusters-and-Extents簇和范围" class="headerlink" title="Clusters and Extents簇和范围"></a>Clusters and Extents簇和范围</h4><p>范围是文件中连续的簇，文件中任何簇都有虚拟簇号LCN针对文件开头的偏移，逻辑簇号LCN针对卷的偏移，但是LCN不保证物理映射</p>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><h3 id="monitor-directory"><a href="#monitor-directory" class="headerlink" title="monitor directory"></a>monitor directory</h3><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findfirstchangenotificationa"><strong>FindFirstChangeNotification</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitformultipleobjects"><strong>WaitForMultipleObjects</strong></a> 等待直到条件满足为止返回</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findnextchangenotification"><strong>FindNextChangeNotification</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findclosechangenotification"><strong>FindCloseChangeNotification</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesw"><strong>ReadDirectoryChangesW</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesexw"><strong>ReadDirectoryChangesExW</strong></a> </p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>dir</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsystemdirectorya"><strong>GetSystemDirectory</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectorya"><strong>GetWindowsDirectory</strong></a> </p>
<h3 id="DOS-Device"><a href="#DOS-Device" class="headerlink" title="DOS Device"></a>DOS Device</h3><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-definedosdevicew"><strong>DefineDosDevice</strong> </a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-setvolumemountpointa"><strong>SetVolumeMountPoint</strong></a>  </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-deletevolumemountpointw"><strong>DeleteVolumeMountPoint</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-querydosdevicew"><strong>QueryDosDevice</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getlogicaldrives"><strong>GetLogicalDrives</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getlogicaldrivestringsw"><strong>GetLogicalDriveStrings</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> sent ctrl</p>
<h3 id="volume卷"><a href="#volume卷" class="headerlink" title="volume卷"></a>volume卷</h3><p>带文件系统的分区，卷与分区一对一关联</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findfirstvolumew"><strong>FindFirstVolume</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findnextvolumew"><strong>FindNextVolume</strong></a> </p>
<p><strong><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a></strong> </p>
<p>info</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getvolumeinformationa"><strong>GetVolumeInformation</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getdrivetypea"><strong>GetDriveType</strong></a> 指定驱动器号引用的卷是可移动驱动器、固定驱动器、CD-ROM、RAM 还是网络驱动器</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getvolumepathnamew"><strong>GetVolumePathName</strong></a> 挂载点</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getvolumenameforvolumemountpointw"><strong>GetVolumeNameForVolumeMountPoint</strong></a> 挂载点对应的卷名</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-setvolumelabela"><strong>SetVolumeLabel</strong></a> 卷标签</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea"><strong>GetDiskFreeSpace</strong></a> 卷的组织信息，包括每个扇区的字节数、每个簇的扇区数、空闲簇的数量和簇的总数，不能报告大于 2 GB 的卷大小</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespaceexa"><strong>GetDiskFreeSpaceEx</strong></a> </p>
<p>journal</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findfirstchangenotificationa"><strong>FindFirstChangeNotification</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesw"><strong>ReadDirectoryChangesW</strong></a> </p>
<p>更新序列号 (USN) </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-fsctl_create_usn_journal"><strong>FSCTL_CREATE_USN_JOURNAL</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-fsctl_delete_usn_journal"><strong>FSCTL_DELETE_USN_JOURNAL</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-fsctl_enum_usn_data"><strong>FSCTL_ENUM_USN_DATA</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-fsctl_mark_handle"><strong>FSCTL_MARK_HANDLE</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-fsctl_query_usn_journal"><strong>FSCTL_QUERY_USN_JOURNAL</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-fsctl_read_usn_journal"><strong>FSCTL_READ_USN_JOURNAL</strong></a> </p>
<p>enum</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-findfirstvolumemountpointa"><strong>FindFirstVolumeMountPoint</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-findnextvolumemountpointa"><strong>FindNextVolumeMountPoint</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-findvolumemountpointclose"><strong>FindVolumeMountPointClose</strong></a> </p>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>handle</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-createfilea"><strong>CreateFile</strong></a> 创建或打开文件</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-openfile"><strong>OpenFile</strong></a> 过时的</p>
<p> <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/handleapi/nf-handleapi-closehandle"><strong>CloseHandle</strong></a> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-lockfile"><strong>LockFile</strong></a> 阻止其他线程duplicate handle写入</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-unlockfile"><strong>UnlockFile</strong></a>  </p>
<p>list</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findfirstfilea"><strong>FindFirstFile</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findfirstfileexa"><strong>FindFirstFileEx</strong></a> advantage search</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findnextfilea"><strong>FindNextFile</strong> </a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findclose"><strong>FindClose</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-searchpatha"><strong>SearchPath</strong></a> path file exist？</p>
<p>move</p>
<p> <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-movefileexa"><strong>MoveFileEx</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-movefilewithprogressa"><strong>MoveFileWithProgress</strong></a> 带有进度通知回调函数</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-movefiletransacteda"><strong>MoveFileTransacted</strong></a> </p>
<p>copy</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-copyfile"><strong>CopyFile</strong></a> 非写入状态</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-copyfileexa"><strong>CopyFileEx</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nc-winbase-lpprogress_routine"><strong>CopyProgressRoutine</strong></a> 进度回调</p>
<p>replace</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-replacefilea"><strong>ReplaceFile</strong></a> 将一个文件替换为另一个文件</p>
<p>delete</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-deletefilea"><strong>DeleteFile</strong></a> </p>
<p>rw</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-readfile"><strong>ReadFile</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-readfileex"><strong>ReadFileEx</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-writefile"><strong>WriteFile</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-writefileex"><strong>WriteFileEx</strong></a> </p>
<p>不连续缓冲区读写</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-readfilescatter"><strong>ReadFileScatter</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-writefilegather"><strong>WriteFileGather</strong> </a> </p>
<p>写入磁盘</p>
<p> <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-flushfilebuffers"><strong>FlushFileBuffers</strong></a> </p>
<p>call <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-createfilea"><strong>CreateFile</strong></a> with flag: <strong>FILE_FLAG_NO_BUFFERING</strong></p>
<p>文件加密</p>
<p>未提及</p>
<p>Sparse File</p>
<p>零散数据文件的高性能读写，未提及</p>
<p>temp</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-gettempfilenamea"><strong>GetTempFileName</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-gettemppatha"><strong>GetTempPath</strong></a> </p>
<p>access privilege</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/aclapi/nf-aclapi-getsecurityinfo"><strong>GetSecurityInfo</strong></a> </p>
<p>backup</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-backupread"><strong>BackupRead</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-backupseek"><strong>BackupSeek</strong> </a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-backupwrite"><strong>BackupWrite</strong></a> </p>
<p>info</p>
<p> <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getfileattributesa"><strong>GetFileAttributes</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getfileattributesexa"><strong>GetFileAttributesEx</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-setfileattributesa"><strong>SetFileAttributes</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getfileinformationbyhandle"><strong>GetFileInformationByHandle</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getfilesize"><strong>GetFileSize</strong></a> （byte）</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getfiletype"><strong>GetFileType</strong></a> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-getbinarytypea"><strong>GetBinaryType</strong></a> executable？</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-getfiletime"><strong>GetFileTime</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfiletime"><strong>SetFileTime</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesw"><strong>ReadDirectoryChangesW</strong></a> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-arefileapisansi"><strong>AreFileApisANSI</strong></a> //whether file I/O functions are using the ANSI or OEM character set code page</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfileapistoansi"><strong>SetFileApisToANSI</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfileapistooem"><strong>SetFileApisToOEM</strong></a> </p>
<h3 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h3><p>current</p>
<p>the directory in which the active application started</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-getcurrentdirectory"><strong>GetCurrentDirectory</strong> </a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getfullpathnamea"><strong>GetFullPathName</strong>  </a> 文件名转换为当前文件夹下文件名对应的完整路径</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-setcurrentdirectory"><strong>SetCurrentDirectory</strong> </a> </p>
<p>handle</p>
<p>call <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-createfilea"><strong>CreateFile</strong></a> with flag: <strong>FILE_FLAG_BACKUP_SEMANTICS</strong></p>
<p>Create</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-createdirectorya"><strong>CreateDirectory</strong></a> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-createdirectoryexa"><strong>CreateDirectoryEx</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-createdirectorytransacteda"><strong>CreateDirectoryTransacted</strong></a> </p>
<p>delete（empty）</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-removedirectorya"><strong>RemoveDirectory</strong></a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/WinBase/nf-winbase-removedirectorytransacteda"><strong>RemoveDirectoryTransacted</strong></a> </p>
<h2 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h2><h3 id="旧系统使用8-3样式命名文件"><a href="#旧系统使用8-3样式命名文件" class="headerlink" title="旧系统使用8.3样式命名文件"></a>旧系统使用8.3样式命名文件</h3><p>8.3 格式的长文件名 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getshortpathnamew"><strong>GetShortPathName</strong></a> </p>
<p>短名称的长文件名版本 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getlongpathnamea"><strong>GetLongPathName</strong></a> </p>
<p>文件的完整路径 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-getfullpathnamea"><strong>GetFullPathName</strong></a> </p>
<h3 id="当前目录"><a href="#当前目录" class="headerlink" title="当前目录"></a>当前目录</h3><p>在路径中使用句点作为目录<em>组件</em>来表示当前目录，例如“.\temp.txt”。</p>
<p>使用两个连续的句点 (..) 作为路径中的目录<em>组件</em>来表示当前目录的父目录，例如“..\temp.txt”。</p>
<p>如果文件名仅以磁盘指示符开头但冒号后没有反斜杠，则将其解释为具有指定字母的驱动器上当前目录的相对路径：“C:tmp.txt”指的是驱动器 C 上当前目录中名为“tmp.txt”的文件；“C:tempdir\tmp.txt”指的是驱动器 C 上当前目录的子目录中的文件。</p>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>任何格式的 UNC 名称，始终以两个反斜杠字符 (“\“) 开头。</p>
<p>带有反斜杠的磁盘指示符，例如“C:\”或“d:\”。</p>
<p>单个反斜杠，例如“\directory”或“\file.txt”。这也称为<em>绝对路径</em>。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>路径字符串的 <code>\\?\</code> 前缀告诉 Windows API 禁用所有字符串解析并将其后面的字符串直接发送到文件系统。</p>
<p> <code>\\.\</code> 前缀将访问 Win32 设备命名空间， </p>
<p><code>\\.\COM56</code> 56号串口</p>
<p><code>\\.\PhysicalDisk X</code> x为整数，指代磁盘 </p>
<p><code>\\.\CdRom X</code> </p>
<p>使用<code>\\.\</code>前缀来仅访问设备而不是文件。大多数 API 不支持 <code>\\.\</code>; </p>
<h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><ul>
<li><p>使用 <code>.</code> 将基本文件名与目录或文件名中的扩展名分开。</p>
</li>
<li><p>使用反斜杠 <code>\</code> 分隔路径的组成部分</p>
</li>
<li><p>不要假设区分大小写。卷指示符（驱动器号）同样不区分大小写。例如，“D:\”和“d:\”指的是同一个卷。</p>
</li>
<li><p>使用当前代码页中的任何字符作为名称，包括 Unicode 字符和扩展字符集 (128–255) 中的字符，但以下字符除外：</p>
<ul>
<li><p>以下保留字符：</p>
<ul>
<li>&lt;（小于）</li>
<li>>（大于）</li>
<li>： （冒号）</li>
<li>“（双引号）</li>
<li>/（正斜杠）</li>
<li>\（反斜杠）</li>
<li>| （垂直条或管）</li>
<li>? （问号）</li>
<li>*（星号）</li>
</ul>
</li>
<li><p>整数值零，有时称为 ASCII <em>NUL</em>字符。</p>
</li>
<li><p>整数表示在 1 到 31 范围内的字符，但允许使用这些字符的备用数据流除外。</p>
</li>
<li><p>目标文件系统不允许的任何其他字符。</p>
</li>
<li><p>不要使用以下保留名称作为文件名：</p>
<p>CON、PRN、AUX、NUL、</p>
<p>COM1、COM2、COM3、COM4、COM5、COM6、COM7、COM8、COM9、</p>
<p>LPT1、LPT2、LPT3、LPT4、LPT5、LPT6、LPT7、LPT8、LPT9。</p>
<p>还要避免这些名称后跟扩展名；例如，不推荐使用 NUL.txt。</p>
</li>
</ul>
</li>
<li><p>不要以空格或句点结尾的文件或目录名称。</p>
</li>
</ul>
<h3 id="最大路径长度"><a href="#最大路径长度" class="headerlink" title="最大路径长度"></a>最大路径长度</h3><p>[X]:\[256个字符]\<NUL>    256+4=260个字符</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/Local%20file%20system/" data-id="cl430wi4w000eakfcgnm041pf" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux shell" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/linux%20shell/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.723Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux-shell"><a href="#linux-shell" class="headerlink" title="linux shell"></a>linux shell</h1><p>命令：[command] [-option] [-…] [arguments]<br>                [command] [-option][…] [arguments]<br>tab键可以用于补全命令</p>
<p>特殊字符:::::<br>命令控制：<br>;分隔命令<br>\延续命令到下一行</p>
<p>通配符：<br>*任意字符或字符串<br>?任意单个字符<br>[字符组]字符组中任一字符<br>[-]</p>
<p>重定向：<br>shell打开标准输入(键盘)，标准输出(屏幕)，标准错误输出(屏幕)三个文件，用重定向符可以更改输入输出流<br>[命令]&lt;[输入文件] 指定输入文件为命令的输入<br>[命令]&lt;&lt;[分隔符] [多行字符串] [分隔符]指定分隔符之间的部分为命令的输入<br>[命令]&gt;[输出文件]指定命令的输出输出到输出文件，不存在则创建，存在则覆盖<br>[命令]&gt;&gt;[输出文件]指定命令的输出追加到输出文件<br>[命令]2&gt;[输出文件]指定命令出错时输出到输出文件<br>[命令]2&gt;&gt;[输出文件]指定命令出错时输出追加到输出文件</p>
<p>管道：<br>[命令] | [命令]将上一个命令的输出输入到下一个命令</p>
<p>引用：<br>[字符] 忽略字符原有的命令含义<br>‘[字符串]’忽略字符串所有特殊字符的命令含义<br>“[字符串]”对 $ \ ` 保留命令含义，其他字符则忽略<br>::::::</p>
<p>命令列表：<br>ls 列出目录内容<br>    -a显示隐藏目录和文件、<br>    -d只显示目录<br>    -R列出目录和子目录下的所有文件<br>    -pF在文件名后添加说明文件类型的字符，/表示目录，@表示链接，|表示FIFO，=表示套接字<br>    -Q输出文件名用双引号引用<br>    -l显示详细信息<br>    -o显示详细信息，排除组信息<br>    -s显示文件大小<br>    -k显示文件大小为多少k<br>    -u按照上次访问顺序排序<br>    -t按照时间排序<br>    -S按照大小排序<br>    -x按列输出，横向排序<br>    -C按列输出，纵向排序<br>    -r反向排序目录<br>    -q以?代替不可输出的字符<br>    -m横向输出文件名，以逗号分隔<br>pwd 显示当前工作目录<br>cd 改变当前工作目录<br>    cd ~ 回到默认工作目录<br>    cd ~[用户名] 回到用户名的默认工作目录<br>    cd .. (cd../) 返回上级目录<br>    cd / 返回到根目录 </p>
<p>passwd 设置密码(termux-auth)<br>passwd [用户名]修改任意用户的密码(root)<br>su 成为超级用户(root)</p>
<pre><code>- 加载root环境变量
-c 只使用超级用户身份执行一条命令
-m不改变环境变量的情况下成为超级用户
</code></pre><p>data 显示系统时间<br>    -s设置系统时间(root)<br>clear 清屏<br>man [命令] 得到指定命令的帮助信息</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/linux%20shell/" data-id="cl430wi4p000dakfc3y2tes7p" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-KnowMap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/KnowMap/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.712Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/KnowMap/" data-id="cl430wi2r0000akfc7ys3eaff" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/JavaScript/" class="article-date">
  <time class="dt-published" datetime="2022-06-06T17:44:37.698Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>文档自上而下加载</li>
<li>console.dir([object])//打印对象和它其内的值</li>
</ol>
<h3 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h3><ul>
<li><p>​    ECMAScript</p>
</li>
<li><p>​    Web-APIs</p>
<ul>
<li><h4 id="DOM-页面元素-Document-Object-Model"><a href="#DOM-页面元素-Document-Object-Model" class="headerlink" title="DOM 页面元素 Document Object Model"></a>DOM 页面元素 Document Object Model</h4></li>
</ul>
<p>​    DOM树 </p>
<pre class="mermaid">  graph LR;
    a([DOM树])
    document-->html;
    html-->head;
    html-->body;
    body-->element;
    element-->attribute;
    element-->text;
    element-->note;</pre>



</li>
</ul>
<ul>
<li><h5 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h5><ul>
<li><p>ID</p>
<p>[element]=getElementById([‘Id’])</p>
</li>
<li><p>标签名，返回伪数组</p>
<p>[Collection]=getElementsByTagName([‘TagName’])</p>
</li>
<li><p>类名（HTML5）</p>
<p>[Collection]=getElementsByClassName([‘ClassName’)</p>
</li>
<li><p>选择器</p>
<p>[element]=querySelector([‘选择器’])</p>
<p>[Collection]=querySelectorAll([‘选择器’])</p>
</li>
<li><p>特别</p>
<p>html: document.documentElement</p>
<p>body: document.body</p>
<p>head: document.head</p>
</li>
</ul>
</li>
<li><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>​    三要素：事件源（元素），事件类型（触发事件），事件处理程序（函数）</p>
<p>​    [事件源].on[事件类型]=function(){}</p>
<p>在function中的this指向事件函数的调用者即事件源</p>
</li>
<li><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ul>
<li><p>文本Text</p>
<p>innerText，文本，去除空格和换行·        </p>
<p>innerHtml，富文本（W3C标准）</p>
</li>
<li><p>属性Attribute</p>
<p>行内样式：style.[样式属性]</p>
<p>​        隐藏：display=’None’</p>
<p>类名：className</p>
<p>​        用于修改批量修改样式</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h5 id="内置对象的使用"><a href="#内置对象的使用" class="headerlink" title="内置对象的使用"></a>内置对象的使用</h5><ul>
<li>Data</li>
</ul>
</li>
<li><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5></li>
<li><p>BOM 浏览器功能</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ni-miruakou.github.io/2022/06/07/JavaScript/" data-id="cl430wi460007akfc5z3407eu" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Es/" rel="tag">Es</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WAP/" rel="tag">WAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/about/" rel="tag">about</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Es/" style="font-size: 10px;">Es</a> <a href="/tags/WAP/" style="font-size: 10px;">WAP</a> <a href="/tags/about/" style="font-size: 10px;">about</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/07/C++/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/07/Android/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/07/UWP/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/07/ProcessService/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/07/OpenGL/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Rongbing<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>